
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;
using Newtonsoft.Json;

//This file contains all the typed querystring parameters that are generated of the client spec.
//This file is automatically generated from https://github.com/elasticsearch/elasticsearch-rest-api-spec
//Generated of commit 

namespace Nest
{

	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IAliasExistsRequest : IRequest<AliasExistsRequestParameters> 
	{
		Indices Index { get; }
		Names Name { get; }
	 } 
	///<summary>Request parameters for IndicesExistsAliasForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class AliasExistsRequest  : RequestBase<AliasExistsRequestParameters>, IAliasExistsRequest
	{
		protected IAliasExistsRequest Self => this;
		Indices IAliasExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IAliasExistsRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_alias/{name}</summary>
///<param name="name">Optional, accepts null</param>
		public AliasExistsRequest(Names name) : base(r=>r.Optional("name", name)){}
		

		/// <summary>/{index}/_alias/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="name">Optional, accepts null</param>
		public AliasExistsRequest(Indices index, Names name) : base(r=>r.Optional("index", index).Optional("name", name)){}
		

		/// <summary>/{index}/_alias</summary>
///<param name="index">Optional, accepts null</param>
		public AliasExistsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IAnalyzeRequest : IRequest<AnalyzeRequestParameters> 
	{
		IndexName Index { get; }
	 } 
	///<summary>Request parameters for IndicesAnalyzeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html</pre></summary>
	public partial class AnalyzeRequest  : RequestBase<AnalyzeRequestParameters>, IAnalyzeRequest
	{
		protected IAnalyzeRequest Self => this;
		IndexName IAnalyzeRequest.Index => Self.RouteValues.Get<IndexName>("index");
			/// <summary>/_analyze</summary>
		public AnalyzeRequest() : base(){}
		

		/// <summary>/{index}/_analyze</summary>
///<param name="index">Optional, accepts null</param>
		public AnalyzeRequest(IndexName index) : base(r=>r.Optional("index", index)){}
		

			///<summary>The name of the analyzer to use</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>A comma-separated list of character filters to use for the analysis</summary>
		public  string[] CharFilters { get { return Q< string[]>("char_filters"); } set { Q("char_filters", value); } }
		
		///<summary>Use the analyzer configured for this field (instead of passing the analyzer name)</summary>
		public FieldName Field { get { return Q<FieldName>("field"); } set { Q("field", value); } }
		
		///<summary>A comma-separated list of filters to use for the analysis</summary>
		public  string[] Filters { get { return Q< string[]>("filters"); } set { Q("filters", value); } }
		
		///<summary>With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)</summary>
		public bool PreferLocal { get { return Q<bool>("prefer_local"); } set { Q("prefer_local", value); } }
		
		///<summary>The text on which the analysis should be performed (when request body is not used)</summary>
		public  string[] Text { get { return Q< string[]>("text"); } set { Q("text", value); } }
		
		///<summary>The name of the tokenizer to use for the analysis</summary>
		public string Tokenizer { get { return Q<string>("tokenizer"); } set { Q("tokenizer", value); } }
		
		///<summary>Format of the output</summary>
		public Format Format { get { return Q<Format>("format"); } set { Q("format", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IBulkAliasRequest : IRequest<BulkAliasRequestParameters> 
	{
	 } 
	///<summary>Request parameters for IndicesUpdateAliasesForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class BulkAliasRequest  : RequestBase<BulkAliasRequestParameters>, IBulkAliasRequest
	{
		protected IBulkAliasRequest Self => this;
				///<summary>Request timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IBulkRequest : IRequest<BulkRequestParameters> 
	{
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Bulk <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-bulk.html</pre></summary>
	public partial class BulkRequest  : RequestBase<BulkRequestParameters>, IBulkRequest
	{
		protected IBulkRequest Self => this;
		IndexName IBulkRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IBulkRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_bulk</summary>
		public BulkRequest() : base(){}
		

		/// <summary>/{index}/_bulk</summary>
///<param name="index">Optional, accepts null</param>
		public BulkRequest(IndexName index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_bulk</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public BulkRequest(IndexName index, TypeName type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Explicit write consistency setting for the operation</summary>
		public Consistency Consistency { get { return Q<Consistency>("consistency"); } set { Q("consistency", value); } }
		
		///<summary>Refresh the index after performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Default comma-separated list of fields to return in the response for updates</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatAliasesRequest : IRequest<CatAliasesRequestParameters> 
	{
		Names Name { get; }
	 } 
	///<summary>Request parameters for CatAliases <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-alias.html</pre></summary>
	public partial class CatAliasesRequest  : RequestBase<CatAliasesRequestParameters>, ICatAliasesRequest
	{
		protected ICatAliasesRequest Self => this;
		Names ICatAliasesRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_cat/aliases</summary>
		public CatAliasesRequest() : base(){}
		

		/// <summary>/_cat/aliases/{name}</summary>
///<param name="name">Optional, accepts null</param>
		public CatAliasesRequest(Names name) : base(r=>r.Optional("name", name)){}
		

			///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatAllocationRequest : IRequest<CatAllocationRequestParameters> 
	{
		NodeIds NodeId { get; }
	 } 
	///<summary>Request parameters for CatAllocation <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-allocation.html</pre></summary>
	public partial class CatAllocationRequest  : RequestBase<CatAllocationRequestParameters>, ICatAllocationRequest
	{
		protected ICatAllocationRequest Self => this;
		NodeIds ICatAllocationRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_cat/allocation</summary>
		public CatAllocationRequest() : base(){}
		

		/// <summary>/_cat/allocation/{node_id}</summary>
///<param name="node_id">Optional, accepts null</param>
		public CatAllocationRequest(NodeIds node_id) : base(r=>r.Optional("node_id", node_id)){}
		

			///<summary>The unit in which to display byte values</summary>
		public Bytes Bytes { get { return Q<Bytes>("bytes"); } set { Q("bytes", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatCountRequest : IRequest<CatCountRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for CatCount <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html</pre></summary>
	public partial class CatCountRequest  : RequestBase<CatCountRequestParameters>, ICatCountRequest
	{
		protected ICatCountRequest Self => this;
		Indices ICatCountRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/count</summary>
		public CatCountRequest() : base(){}
		

		/// <summary>/_cat/count/{index}</summary>
///<param name="index">Optional, accepts null</param>
		public CatCountRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatFielddataRequest : IRequest<CatFielddataRequestParameters> 
	{
		FieldNames Fields { get; }
	 } 
	///<summary>Request parameters for CatFielddata <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html</pre></summary>
	public partial class CatFielddataRequest  : RequestBase<CatFielddataRequestParameters>, ICatFielddataRequest
	{
		protected ICatFielddataRequest Self => this;
		FieldNames ICatFielddataRequest.Fields => Self.RouteValues.Get<FieldNames>("fields");
			/// <summary>/_cat/fielddata</summary>
		public CatFielddataRequest() : base(){}
		

		/// <summary>/_cat/fielddata/{fields}</summary>
///<param name="fields">Optional, accepts null</param>
		public CatFielddataRequest(FieldNames fields) : base(r=>r.Optional("fields", fields)){}
		

			///<summary>The unit in which to display byte values</summary>
		public Bytes Bytes { get { return Q<Bytes>("bytes"); } set { Q("bytes", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatHealthRequest : IRequest<CatHealthRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatHealth <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html</pre></summary>
	public partial class CatHealthRequest  : RequestBase<CatHealthRequestParameters>, ICatHealthRequest
	{
		protected ICatHealthRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Set to false to disable timestamping</summary>
		public bool Ts { get { return Q<bool>("ts"); } set { Q("ts", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatHelpRequest : IRequest<CatHelpRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatHelp <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html</pre></summary>
	public partial class CatHelpRequest  : RequestBase<CatHelpRequestParameters>, ICatHelpRequest
	{
		protected ICatHelpRequest Self => this;
				///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		//TODO THIS METHOD IS UNMAPPED!
	
	}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatIndicesRequest : IRequest<CatIndicesRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for CatIndices <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-indices.html</pre></summary>
	public partial class CatIndicesRequest  : RequestBase<CatIndicesRequestParameters>, ICatIndicesRequest
	{
		protected ICatIndicesRequest Self => this;
		Indices ICatIndicesRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/indices</summary>
		public CatIndicesRequest() : base(){}
		

		/// <summary>/_cat/indices/{index}</summary>
///<param name="index">Optional, accepts null</param>
		public CatIndicesRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>The unit in which to display byte values</summary>
		public Bytes Bytes { get { return Q<Bytes>("bytes"); } set { Q("bytes", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Set to true to return stats only for primary shards</summary>
		public bool Pri { get { return Q<bool>("pri"); } set { Q("pri", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatMasterRequest : IRequest<CatMasterRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatMaster <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-master.html</pre></summary>
	public partial class CatMasterRequest  : RequestBase<CatMasterRequestParameters>, ICatMasterRequest
	{
		protected ICatMasterRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatNodeattrsRequest : IRequest<CatNodeattrsRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatNodeattrs <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodeattrs.html</pre></summary>
	public partial class CatNodeattrsRequest  : RequestBase<CatNodeattrsRequestParameters>, ICatNodeattrsRequest
	{
		protected ICatNodeattrsRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		//TODO THIS METHOD IS UNMAPPED!
	
	}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatNodesRequest : IRequest<CatNodesRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatNodes <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodes.html</pre></summary>
	public partial class CatNodesRequest  : RequestBase<CatNodesRequestParameters>, ICatNodesRequest
	{
		protected ICatNodesRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatPendingTasksRequest : IRequest<CatPendingTasksRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatPendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-pending-tasks.html</pre></summary>
	public partial class CatPendingTasksRequest  : RequestBase<CatPendingTasksRequestParameters>, ICatPendingTasksRequest
	{
		protected ICatPendingTasksRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatPluginsRequest : IRequest<CatPluginsRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatPlugins <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html</pre></summary>
	public partial class CatPluginsRequest  : RequestBase<CatPluginsRequestParameters>, ICatPluginsRequest
	{
		protected ICatPluginsRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatRecoveryRequest : IRequest<CatRecoveryRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for CatRecovery <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html</pre></summary>
	public partial class CatRecoveryRequest  : RequestBase<CatRecoveryRequestParameters>, ICatRecoveryRequest
	{
		protected ICatRecoveryRequest Self => this;
		Indices ICatRecoveryRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/recovery</summary>
		public CatRecoveryRequest() : base(){}
		

		/// <summary>/_cat/recovery/{index}</summary>
///<param name="index">Optional, accepts null</param>
		public CatRecoveryRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>The unit in which to display byte values</summary>
		public Bytes Bytes { get { return Q<Bytes>("bytes"); } set { Q("bytes", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatSegmentsRequest : IRequest<CatSegmentsRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for CatSegments <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html</pre></summary>
	public partial class CatSegmentsRequest  : RequestBase<CatSegmentsRequestParameters>, ICatSegmentsRequest
	{
		protected ICatSegmentsRequest Self => this;
		Indices ICatSegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/segments</summary>
		public CatSegmentsRequest() : base(){}
		

		/// <summary>/_cat/segments/{index}</summary>
///<param name="index">Optional, accepts null</param>
		public CatSegmentsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatShardsRequest : IRequest<CatShardsRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for CatShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-shards.html</pre></summary>
	public partial class CatShardsRequest  : RequestBase<CatShardsRequestParameters>, ICatShardsRequest
	{
		protected ICatShardsRequest Self => this;
		Indices ICatShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/shards</summary>
		public CatShardsRequest() : base(){}
		

		/// <summary>/_cat/shards/{index}</summary>
///<param name="index">Optional, accepts null</param>
		public CatShardsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICatThreadPoolRequest : IRequest<CatThreadPoolRequestParameters> 
	{
	 } 
	///<summary>Request parameters for CatThreadPool <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html</pre></summary>
	public partial class CatThreadPoolRequest  : RequestBase<CatThreadPoolRequestParameters>, ICatThreadPoolRequest
	{
		protected ICatThreadPoolRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Comma-separated list of column names to display</summary>
		public  string[] H { get { return Q< string[]>("h"); } set { Q("h", value); } }
		
		///<summary>Return help information</summary>
		public bool Help { get { return Q<bool>("help"); } set { Q("help", value); } }
		
		///<summary>Verbose mode. Display column headers</summary>
		public bool V { get { return Q<bool>("v"); } set { Q("v", value); } }
		
		///<summary>Enables displaying the complete node ids</summary>
		public bool FullId { get { return Q<bool>("full_id"); } set { Q("full_id", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClearCacheRequest : IRequest<ClearCacheRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesClearCacheForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-clearcache.html</pre></summary>
	public partial class ClearCacheRequest  : RequestBase<ClearCacheRequestParameters>, IClearCacheRequest
	{
		protected IClearCacheRequest Self => this;
		Indices IClearCacheRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cache/clear</summary>
		public ClearCacheRequest() : base(){}
		

		/// <summary>/{index}/_cache/clear</summary>
///<param name="index">Optional, accepts null</param>
		public ClearCacheRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Clear field data</summary>
		public bool FieldData { get { return Q<bool>("field_data"); } set { Q("field_data", value); } }
		
		///<summary>A comma-separated list of fields to clear when using the `field_data` parameter (default: all)</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>Clear query caches</summary>
		public bool Query { get { return Q<bool>("query"); } set { Q("query", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Clear the recycler cache</summary>
		public bool Recycler { get { return Q<bool>("recycler"); } set { Q("recycler", value); } }
		
		///<summary>Clear request cache</summary>
		public bool Request { get { return Q<bool>("request"); } set { Q("request", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClearScrollRequest : IRequest<ClearScrollRequestParameters> 
	{
		ScrollIds ScrollId { get; }
	 } 
	///<summary>Request parameters for ClearScroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ClearScrollRequest  : RequestBase<ClearScrollRequestParameters>, IClearScrollRequest
	{
		protected IClearScrollRequest Self => this;
		ScrollIds IClearScrollRequest.ScrollId => Self.RouteValues.Get<ScrollIds>("scroll_id");
			/// <summary>/_search/scroll/{scroll_id}</summary>
///<param name="scroll_id">Optional, accepts null</param>
		public ClearScrollRequest(ScrollIds scroll_id) : base(r=>r.Optional("scroll_id", scroll_id)){}
		

		/// <summary>/_search/scroll</summary>
		public ClearScrollRequest() : base(){}
		

			///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICloseIndexRequest : IRequest<CloseIndexRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesClose <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class CloseIndexRequest  : RequestBase<CloseIndexRequestParameters>, ICloseIndexRequest
	{
		protected ICloseIndexRequest Self => this;
		Indices ICloseIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}/_close</summary>
///<param name="index">this parameter is required</param>
		public CloseIndexRequest(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClusterGetSettingsRequest : IRequest<ClusterGetSettingsRequestParameters> 
	{
	 } 
	///<summary>Request parameters for ClusterGetSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterGetSettingsRequest  : RequestBase<ClusterGetSettingsRequestParameters>, IClusterGetSettingsRequest
	{
		protected IClusterGetSettingsRequest Self => this;
				///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClusterHealthRequest : IRequest<ClusterHealthRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for ClusterHealth <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html</pre></summary>
	public partial class ClusterHealthRequest  : RequestBase<ClusterHealthRequestParameters>, IClusterHealthRequest
	{
		protected IClusterHealthRequest Self => this;
		Indices IClusterHealthRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cluster/health</summary>
		public ClusterHealthRequest() : base(){}
		

		/// <summary>/_cluster/health/{index}</summary>
///<param name="index">Optional, accepts null</param>
		public ClusterHealthRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Specify the level of detail for returned information</summary>
		public Level Level { get { return Q<Level>("level"); } set { Q("level", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Wait until the specified number of shards is active</summary>
		public long WaitForActiveShards { get { return Q<long>("wait_for_active_shards"); } set { Q("wait_for_active_shards", value); } }
		
		///<summary>Wait until the specified number of nodes is available</summary>
		public string WaitForNodes { get { return Q<string>("wait_for_nodes"); } set { Q("wait_for_nodes", value); } }
		
		///<summary>Wait until the specified number of relocating shards is finished</summary>
		public long WaitForRelocatingShards { get { return Q<long>("wait_for_relocating_shards"); } set { Q("wait_for_relocating_shards", value); } }
		
		///<summary>Wait until cluster is in a specific state</summary>
		public WaitForStatus WaitForStatus { get { return Q<WaitForStatus>("wait_for_status"); } set { Q("wait_for_status", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClusterPendingTasksRequest : IRequest<ClusterPendingTasksRequestParameters> 
	{
	 } 
	///<summary>Request parameters for ClusterPendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-pending.html</pre></summary>
	public partial class ClusterPendingTasksRequest  : RequestBase<ClusterPendingTasksRequestParameters>, IClusterPendingTasksRequest
	{
		protected IClusterPendingTasksRequest Self => this;
				///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClusterPutSettingsRequest : IRequest<ClusterPutSettingsRequestParameters> 
	{
	 } 
	///<summary>Request parameters for ClusterPutSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterPutSettingsRequest  : RequestBase<ClusterPutSettingsRequestParameters>, IClusterPutSettingsRequest
	{
		protected IClusterPutSettingsRequest Self => this;
				///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClusterRerouteRequest : IRequest<ClusterRerouteRequestParameters> 
	{
	 } 
	///<summary>Request parameters for ClusterReroute <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-reroute.html</pre></summary>
	public partial class ClusterRerouteRequest  : RequestBase<ClusterRerouteRequestParameters>, IClusterRerouteRequest
	{
		protected IClusterRerouteRequest Self => this;
				///<summary>Simulate the operation only and return the resulting state</summary>
		public bool DryRun { get { return Q<bool>("dry_run"); } set { Q("dry_run", value); } }
		
		///<summary>Return an explanation of why the commands can or cannot be executed</summary>
		public bool Explain { get { return Q<bool>("explain"); } set { Q("explain", value); } }
		
		///<summary>Limit the information returned to the specified metrics. Defaults to all but metadata</summary>
		public  string[] Metric { get { return Q< string[]>("metric"); } set { Q("metric", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClusterStateRequest : IRequest<ClusterStateRequestParameters> 
	{
		Indices Index { get; }
		Metrics Metric { get; }
	 } 
	///<summary>Request parameters for ClusterState <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-state.html</pre></summary>
	public partial class ClusterStateRequest  : RequestBase<ClusterStateRequestParameters>, IClusterStateRequest
	{
		protected IClusterStateRequest Self => this;
		Indices IClusterStateRequest.Index => Self.RouteValues.Get<Indices>("index");
		Metrics IClusterStateRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
			/// <summary>/_cluster/state</summary>
		public ClusterStateRequest() : base(){}
		

		/// <summary>/_cluster/state/{metric}</summary>
///<param name="metric">Optional, accepts null</param>
		public ClusterStateRequest(ClusterStateMetric metric) : base(r=>r.Optional("metric", (Metrics)metric)){}
		

		/// <summary>/_cluster/state/{metric}/{index}</summary>
///<param name="metric">Optional, accepts null</param>		
///<param name="index">Optional, accepts null</param>
		public ClusterStateRequest(ClusterStateMetric metric, Indices index) : base(r=>r.Optional("metric", (Metrics)metric).Optional("index", index)){}
		

			///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IClusterStatsRequest : IRequest<ClusterStatsRequestParameters> 
	{
		NodeIds NodeId { get; }
	 } 
	///<summary>Request parameters for ClusterStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-stats.html</pre></summary>
	public partial class ClusterStatsRequest  : RequestBase<ClusterStatsRequestParameters>, IClusterStatsRequest
	{
		protected IClusterStatsRequest Self => this;
		NodeIds IClusterStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_cluster/stats</summary>
		public ClusterStatsRequest() : base(){}
		

		/// <summary>/_cluster/stats/nodes/{node_id}</summary>
///<param name="node_id">Optional, accepts null</param>
		public ClusterStatsRequest(NodeIds node_id) : base(r=>r.Optional("node_id", node_id)){}
		

			///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICountRequest : IRequest<CountRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html</pre></summary>
	public partial class CountRequest<T>  : RequestBase<CountRequestParameters>, ICountRequest
	{
		protected ICountRequest Self => this;
		Indices ICountRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ICountRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_count</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public CountRequest() : this(typeof(T), typeof(T)) {}
		

		/// <summary>/{index}/_count</summary>
///<param name="index">Optional, accepts null</param>
		public CountRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_count</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public CountRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public double MinScore { get { return Q<double>("min_score"); } set { Q("min_score", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html</pre></summary>
	public partial class CountRequest  : RequestBase<CountRequestParameters>, ICountRequest
	{
		protected ICountRequest Self => this;
		Indices ICountRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ICountRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_count</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public CountRequest() {}
		

		/// <summary>/{index}/_count</summary>
///<param name="index">Optional, accepts null</param>
		public CountRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_count</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public CountRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public double MinScore { get { return Q<double>("min_score"); } set { Q("min_score", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICreateIndexRequest : IRequest<CreateIndexRequestParameters> 
	{
		IndexName Index { get; }
	 } 
	///<summary>Request parameters for IndicesCreate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html</pre></summary>
	public partial class CreateIndexRequest  : RequestBase<CreateIndexRequestParameters>, ICreateIndexRequest
	{
		protected ICreateIndexRequest Self => this;
		IndexName ICreateIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
			/// <summary>/{index}</summary>
///<param name="index">this parameter is required</param>
		public CreateIndexRequest(IndexName index) : base(r=>r.Required("index", index)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Whether to update the mapping for all fields with the same name across all types or not</summary>
		public bool UpdateAllTypes { get { return Q<bool>("update_all_types"); } set { Q("update_all_types", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ICreateRepositoryRequest : IRequest<CreateRepositoryRequestParameters> 
	{
		Name RepositoryName { get; }
	 } 
	///<summary>Request parameters for SnapshotCreateRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class CreateRepositoryRequest  : RequestBase<CreateRepositoryRequestParameters>, ICreateRepositoryRequest
	{
		protected ICreateRepositoryRequest Self => this;
		Name ICreateRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
			/// <summary>/_snapshot/{repository}</summary>
///<param name="repository">this parameter is required</param>
		public CreateRepositoryRequest(Name repository) : base(r=>r.Required("repository", repository)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Whether to verify the repository after creation</summary>
		public bool Verify { get { return Q<bool>("verify"); } set { Q("verify", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteAliasRequest : IRequest<DeleteAliasRequestParameters> 
	{
		Indices Index { get; }
		Names Name { get; }
	 } 
	///<summary>Request parameters for IndicesDeleteAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class DeleteAliasRequest  : RequestBase<DeleteAliasRequestParameters>, IDeleteAliasRequest
	{
		protected IDeleteAliasRequest Self => this;
		Indices IDeleteAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IDeleteAliasRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/{index}/_alias/{name}</summary>
///<param name="index">this parameter is required</param>		
///<param name="name">this parameter is required</param>
		public DeleteAliasRequest(Indices index, Names name) : base(r=>r.Required("index", index).Required("name", name)){}
		

			///<summary>Explicit timestamp for the document</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteByQueryRequest : IRequest<DeleteByQueryRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for DeleteByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/2.0/plugins-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryRequest<T>  : RequestBase<DeleteByQueryRequestParameters>, IDeleteByQueryRequest
	{
		protected IDeleteByQueryRequest Self => this;
		Indices IDeleteByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IDeleteByQueryRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/_query</summary>
///<param name="index">this parameter is required</param>
		public DeleteByQueryRequest(Indices index) : base(r=>r.Required("index", index)){}
		

		/// <summary>/{index}/{type}/_query</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">Optional, accepts null</param>
		public DeleteByQueryRequest(Indices index, Types type) : base(r=>r.Required("index", index).Optional("type", type)){}
		

			///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for DeleteByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/2.0/plugins-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryRequest  : RequestBase<DeleteByQueryRequestParameters>, IDeleteByQueryRequest
	{
		protected IDeleteByQueryRequest Self => this;
		Indices IDeleteByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IDeleteByQueryRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/_query</summary>
///<param name="index">this parameter is required</param>
		public DeleteByQueryRequest(Indices index) : base(r=>r.Required("index", index)){}
		

		/// <summary>/{index}/{type}/_query</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">Optional, accepts null</param>
		public DeleteByQueryRequest(Indices index, Types type) : base(r=>r.Required("index", index).Optional("type", type)){}
		

			///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteIndexRequest : IRequest<DeleteIndexRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesDelete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html</pre></summary>
	public partial class DeleteIndexRequest  : RequestBase<DeleteIndexRequestParameters>, IDeleteIndexRequest
	{
		protected IDeleteIndexRequest Self => this;
		Indices IDeleteIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}</summary>
///<param name="index">this parameter is required</param>
		public DeleteIndexRequest(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteIndexTemplateRequest : IRequest<DeleteIndexTemplateRequestParameters> 
	{
		Name Name { get; }
	 } 
	///<summary>Request parameters for IndicesDeleteTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class DeleteIndexTemplateRequest  : RequestBase<DeleteIndexTemplateRequestParameters>, IDeleteIndexTemplateRequest
	{
		protected IDeleteIndexTemplateRequest Self => this;
		Name IDeleteIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/_template/{name}</summary>
///<param name="name">this parameter is required</param>
		public DeleteIndexTemplateRequest(Name name) : base(r=>r.Required("name", name)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteRepositoryRequest : IRequest<DeleteRepositoryRequestParameters> 
	{
		Names RepositoryName { get; }
	 } 
	///<summary>Request parameters for SnapshotDeleteRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteRepositoryRequest  : RequestBase<DeleteRepositoryRequestParameters>, IDeleteRepositoryRequest
	{
		protected IDeleteRepositoryRequest Self => this;
		Names IDeleteRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
			/// <summary>/_snapshot/{repository}</summary>
///<param name="repository">this parameter is required</param>
		public DeleteRepositoryRequest(Names repository) : base(r=>r.Required("repository", repository)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteRequest : IRequest<DeleteRequestParameters> 
	{
		Id Id { get; }
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Delete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html</pre></summary>
	public partial class DeleteRequest<T>  : RequestBase<DeleteRequestParameters>, IDeleteRequest
	{
		protected IDeleteRequest Self => this;
		Id IDeleteRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDeleteRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDeleteRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public DeleteRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public DeleteRequest(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>Specific write consistency setting for the operation</summary>
		public Consistency Consistency { get { return Q<Consistency>("consistency"); } set { Q("consistency", value); } }
		
		///<summary>ID of parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Refresh the index after performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for Delete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html</pre></summary>
	public partial class DeleteRequest  : RequestBase<DeleteRequestParameters>, IDeleteRequest
	{
		protected IDeleteRequest Self => this;
		Id IDeleteRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDeleteRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDeleteRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public DeleteRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

			///<summary>Specific write consistency setting for the operation</summary>
		public Consistency Consistency { get { return Q<Consistency>("consistency"); } set { Q("consistency", value); } }
		
		///<summary>ID of parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Refresh the index after performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteScriptRequest : IRequest<DeleteScriptRequestParameters> 
	{
		Id Id { get; }
		Name Lang { get; }
	 } 
	///<summary>Request parameters for DeleteScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class DeleteScriptRequest  : RequestBase<DeleteScriptRequestParameters>, IDeleteScriptRequest
	{
		protected IDeleteScriptRequest Self => this;
		Id IDeleteScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IDeleteScriptRequest.Lang => Self.RouteValues.Get<Name>("lang");
			/// <summary>/_scripts/{lang}/{id}</summary>
///<param name="lang">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public DeleteScriptRequest(Name lang, Id id) : base(r=>r.Required("lang", lang).Required("id", id)){}
		

			///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteSearchTemplateRequest : IRequest<DeleteSearchTemplateRequestParameters> 
	{
		Id Id { get; }
	 } 
	///<summary>Request parameters for DeleteTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class DeleteSearchTemplateRequest  : RequestBase<DeleteSearchTemplateRequestParameters>, IDeleteSearchTemplateRequest
	{
		protected IDeleteSearchTemplateRequest Self => this;
		Id IDeleteSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_search/template/{id}</summary>
///<param name="id">this parameter is required</param>
		public DeleteSearchTemplateRequest(Id id) : base(r=>r.Required("id", id)){}
		

			///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteSnapshotRequest : IRequest<DeleteSnapshotRequestParameters> 
	{
		Name RepositoryName { get; }
		Name Snapshot { get; }
	 } 
	///<summary>Request parameters for SnapshotDelete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteSnapshotRequest  : RequestBase<DeleteSnapshotRequestParameters>, IDeleteSnapshotRequest
	{
		protected IDeleteSnapshotRequest Self => this;
		Name IDeleteSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IDeleteSnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}</summary>
///<param name="repository">this parameter is required</param>		
///<param name="snapshot">this parameter is required</param>
		public DeleteSnapshotRequest(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDeleteWarmerRequest : IRequest<DeleteWarmerRequestParameters> 
	{
		Indices Index { get; }
		Names Name { get; }
	 } 
	///<summary>Request parameters for IndicesDeleteWarmer <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html</pre></summary>
	public partial class DeleteWarmerRequest  : RequestBase<DeleteWarmerRequestParameters>, IDeleteWarmerRequest
	{
		protected IDeleteWarmerRequest Self => this;
		Indices IDeleteWarmerRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IDeleteWarmerRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/{index}/_warmer/{name}</summary>
///<param name="index">this parameter is required</param>		
///<param name="name">this parameter is required</param>
		public DeleteWarmerRequest(Indices index, Names name) : base(r=>r.Required("index", index).Required("name", name)){}
		

			///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IDocumentExistsRequest : IRequest<DocumentExistsRequestParameters> 
	{
		Id Id { get; }
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Exists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class DocumentExistsRequest<T>  : RequestBase<DocumentExistsRequestParameters>, IDocumentExistsRequest
	{
		protected IDocumentExistsRequest Self => this;
		Id IDocumentExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDocumentExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDocumentExistsRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public DocumentExistsRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public DocumentExistsRequest(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>The ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for Exists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class DocumentExistsRequest  : RequestBase<DocumentExistsRequestParameters>, IDocumentExistsRequest
	{
		protected IDocumentExistsRequest Self => this;
		Id IDocumentExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDocumentExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDocumentExistsRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public DocumentExistsRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

			///<summary>The ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IExplainRequest<TDocument> : IRequest<ExplainRequestParameters> 
	{
		Id Id { get; }
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Explain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html</pre></summary>
	public partial class ExplainRequest<TDocument>  : RequestBase<ExplainRequestParameters>, IExplainRequest<TDocument>
	{
		protected IExplainRequest<TDocument> Self => this;
		Id IExplainRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IExplainRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IExplainRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}/_explain</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public ExplainRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}/_explain</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public ExplainRequest(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The analyzer for the query string query</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The default field for query string query (default: _all)</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>A comma-separated list of fields to return in the response</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>The ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public  string[] SourceEnabled { get { return Q< string[]>("_source"); } set { Q("_source", value); } }
		
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public FieldNames SourceExclude { get { return Q<FieldNames>("_source_exclude"); } set { Q("_source_exclude", value); } }
		
		///<summary>A list of fields to extract and return from the _source field</summary>
		public FieldNames SourceInclude { get { return Q<FieldNames>("_source_include"); } set { Q("_source_include", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IFieldStatsRequest : IRequest<FieldStatsRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for FieldStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html</pre></summary>
	public partial class FieldStatsRequest  : RequestBase<FieldStatsRequestParameters>, IFieldStatsRequest
	{
		protected IFieldStatsRequest Self => this;
		Indices IFieldStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_field_stats</summary>
		public FieldStatsRequest() : base(){}
		

		/// <summary>/{index}/_field_stats</summary>
///<param name="index">Optional, accepts null</param>
		public FieldStatsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>A comma-separated list of fields for to get field statistics for (min value, max value, and more)</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>Defines if field stats should be returned on a per index level or on a cluster wide level</summary>
		public Level Level { get { return Q<Level>("level"); } set { Q("level", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IFlushRequest : IRequest<FlushRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesFlushForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-flush.html</pre></summary>
	public partial class FlushRequest  : RequestBase<FlushRequestParameters>, IFlushRequest
	{
		protected IFlushRequest Self => this;
		Indices IFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_flush</summary>
		public FlushRequest() : base(){}
		

		/// <summary>/{index}/_flush</summary>
///<param name="index">Optional, accepts null</param>
		public FlushRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)</summary>
		public bool Force { get { return Q<bool>("force"); } set { Q("force", value); } }
		
		///<summary>If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is false and will cause an exception to be thrown on the shard level if another flush operation is already running.</summary>
		public bool WaitIfOngoing { get { return Q<bool>("wait_if_ongoing"); } set { Q("wait_if_ongoing", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetAliasesRequest : IRequest<GetAliasesRequestParameters> 
	{
		Indices Index { get; }
		Names Name { get; }
	 } 
	///<summary>Request parameters for IndicesGetAliasesForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class GetAliasesRequest  : RequestBase<GetAliasesRequestParameters>, IGetAliasesRequest
	{
		protected IGetAliasesRequest Self => this;
		Indices IGetAliasesRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetAliasesRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_aliases</summary>
		public GetAliasesRequest() : base(){}
		

		/// <summary>/{index}/_aliases</summary>
///<param name="index">Optional, accepts null</param>
		public GetAliasesRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/_aliases/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="name">Optional, accepts null</param>
		public GetAliasesRequest(Indices index, Names name) : base(r=>r.Optional("index", index).Optional("name", name)){}
		

		/// <summary>/_aliases/{name}</summary>
///<param name="name">Optional, accepts null</param>
		public GetAliasesRequest(Names name) : base(r=>r.Optional("name", name)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetAliasRequest : IRequest<GetAliasRequestParameters> 
	{
		Indices Index { get; }
		Names Name { get; }
	 } 
	///<summary>Request parameters for IndicesGetAliasForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class GetAliasRequest  : RequestBase<GetAliasRequestParameters>, IGetAliasRequest
	{
		protected IGetAliasRequest Self => this;
		Indices IGetAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetAliasRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_alias</summary>
		public GetAliasRequest() : base(){}
		

		/// <summary>/_alias/{name}</summary>
///<param name="name">Optional, accepts null</param>
		public GetAliasRequest(Names name) : base(r=>r.Optional("name", name)){}
		

		/// <summary>/{index}/_alias/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="name">Optional, accepts null</param>
		public GetAliasRequest(Indices index, Names name) : base(r=>r.Optional("index", index).Optional("name", name)){}
		

		/// <summary>/{index}/_alias</summary>
///<param name="index">Optional, accepts null</param>
		public GetAliasRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetFieldMappingRequest : IRequest<GetFieldMappingRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
		FieldNames Fields { get; }
	 } 
	///<summary>Request parameters for IndicesGetFieldMappingForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-field-mapping.html</pre></summary>
	public partial class GetFieldMappingRequest  : RequestBase<GetFieldMappingRequestParameters>, IGetFieldMappingRequest
	{
		protected IGetFieldMappingRequest Self => this;
		Indices IGetFieldMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IGetFieldMappingRequest.Type => Self.RouteValues.Get<Types>("type");
		FieldNames IGetFieldMappingRequest.Fields => Self.RouteValues.Get<FieldNames>("fields");
			/// <summary>/_mapping/field/{fields}</summary>
///<param name="fields">this parameter is required</param>
		public GetFieldMappingRequest(FieldNames fields) : base(r=>r.Required("fields", fields)){}
		

		/// <summary>/{index}/_mapping/field/{fields}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="fields">this parameter is required</param>
		public GetFieldMappingRequest(Indices index, FieldNames fields) : base(r=>r.Optional("index", index).Required("fields", fields)){}
		

		/// <summary>/_mapping/{type}/field/{fields}</summary>
///<param name="type">Optional, accepts null</param>		
///<param name="fields">this parameter is required</param>
		public GetFieldMappingRequest(Types type, FieldNames fields) : base(r=>r.Optional("type", type).Required("fields", fields)){}
		

		/// <summary>/{index}/_mapping/{type}/field/{fields}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>		
///<param name="fields">this parameter is required</param>
		public GetFieldMappingRequest(Indices index, Types type, FieldNames fields) : base(r=>r.Optional("index", index).Optional("type", type).Required("fields", fields)){}
		

			///<summary>Whether the default mapping values should be returned as well</summary>
		public bool IncludeDefaults { get { return Q<bool>("include_defaults"); } set { Q("include_defaults", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetIndexRequest : IRequest<GetIndexRequestParameters> 
	{
		Indices Index { get; }
		Features Feature { get; }
	 } 
	///<summary>Request parameters for IndicesGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html</pre></summary>
	public partial class GetIndexRequest  : RequestBase<GetIndexRequestParameters>, IGetIndexRequest
	{
		protected IGetIndexRequest Self => this;
		Indices IGetIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		Features IGetIndexRequest.Feature => Self.RouteValues.Get<Features>("feature");
			/// <summary>/{index}</summary>
///<param name="index">this parameter is required</param>
		public GetIndexRequest(Indices index) : base(r=>r.Required("index", index)){}
		

		/// <summary>/{index}/{feature}</summary>
///<param name="index">this parameter is required</param>		
///<param name="feature">Optional, accepts null</param>
		public GetIndexRequest(Indices index, Features feature) : base(r=>r.Required("index", index).Optional("feature", feature)){}
		

			///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Ignore unavailable indexes (default: false)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Whether to return version and creation date values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetIndexSettingsRequest : IRequest<GetIndexSettingsRequestParameters> 
	{
		Indices Index { get; }
		Names Name { get; }
	 } 
	///<summary>Request parameters for IndicesGetSettingsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html</pre></summary>
	public partial class GetIndexSettingsRequest  : RequestBase<GetIndexSettingsRequestParameters>, IGetIndexSettingsRequest
	{
		protected IGetIndexSettingsRequest Self => this;
		Indices IGetIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetIndexSettingsRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_settings</summary>
		public GetIndexSettingsRequest() : base(){}
		

		/// <summary>/{index}/_settings</summary>
///<param name="index">Optional, accepts null</param>
		public GetIndexSettingsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/_settings/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="name">Optional, accepts null</param>
		public GetIndexSettingsRequest(Indices index, Names name) : base(r=>r.Optional("index", index).Optional("name", name)){}
		

		/// <summary>/_settings/{name}</summary>
///<param name="name">Optional, accepts null</param>
		public GetIndexSettingsRequest(Names name) : base(r=>r.Optional("name", name)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Whether to return version and creation date values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetIndexTemplateRequest : IRequest<GetIndexTemplateRequestParameters> 
	{
		Names Name { get; }
	 } 
	///<summary>Request parameters for IndicesGetTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class GetIndexTemplateRequest  : RequestBase<GetIndexTemplateRequestParameters>, IGetIndexTemplateRequest
	{
		protected IGetIndexTemplateRequest Self => this;
		Names IGetIndexTemplateRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_template</summary>
		public GetIndexTemplateRequest() : base(){}
		

		/// <summary>/_template/{name}</summary>
///<param name="name">Optional, accepts null</param>
		public GetIndexTemplateRequest(Names name) : base(r=>r.Optional("name", name)){}
		

			///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetMappingRequest : IRequest<GetMappingRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for IndicesGetMappingForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html</pre></summary>
	public partial class GetMappingRequest  : RequestBase<GetMappingRequestParameters>, IGetMappingRequest
	{
		protected IGetMappingRequest Self => this;
		Indices IGetMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IGetMappingRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_mapping</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public GetMappingRequest() {}
		

		/// <summary>/{index}/_mapping</summary>
///<param name="index">Optional, accepts null</param>
		public GetMappingRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/_mapping/{type}</summary>
///<param name="type">Optional, accepts null</param>
		public GetMappingRequest(Types type) : base(r=>r.Optional("type", type)){}
		

		/// <summary>/{index}/_mapping/{type}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public GetMappingRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetRepositoryRequest : IRequest<GetRepositoryRequestParameters> 
	{
		Names RepositoryName { get; }
	 } 
	///<summary>Request parameters for SnapshotGetRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetRepositoryRequest  : RequestBase<GetRepositoryRequestParameters>, IGetRepositoryRequest
	{
		protected IGetRepositoryRequest Self => this;
		Names IGetRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
			/// <summary>/_snapshot</summary>
		public GetRepositoryRequest() : base(){}
		

		/// <summary>/_snapshot/{repository}</summary>
///<param name="repository">Optional, accepts null</param>
		public GetRepositoryRequest(Names repository) : base(r=>r.Optional("repository", repository)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetRequest : IRequest<GetRequestParameters> 
	{
		Id Id { get; }
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Get <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class GetRequest<T>  : RequestBase<GetRequestParameters>, IGetRequest
	{
		protected IGetRequest Self => this;
		Id IGetRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IGetRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public GetRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public GetRequest(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>A comma-separated list of fields to return in the response</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>The ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public  string[] SourceEnabled { get { return Q< string[]>("_source"); } set { Q("_source", value); } }
		
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public FieldNames SourceExclude { get { return Q<FieldNames>("_source_exclude"); } set { Q("_source_exclude", value); } }
		
		///<summary>A list of fields to extract and return from the _source field</summary>
		public FieldNames SourceInclude { get { return Q<FieldNames>("_source_include"); } set { Q("_source_include", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for Get <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class GetRequest  : RequestBase<GetRequestParameters>, IGetRequest
	{
		protected IGetRequest Self => this;
		Id IGetRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IGetRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public GetRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

			///<summary>A comma-separated list of fields to return in the response</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>The ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public  string[] SourceEnabled { get { return Q< string[]>("_source"); } set { Q("_source", value); } }
		
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public FieldNames SourceExclude { get { return Q<FieldNames>("_source_exclude"); } set { Q("_source_exclude", value); } }
		
		///<summary>A list of fields to extract and return from the _source field</summary>
		public FieldNames SourceInclude { get { return Q<FieldNames>("_source_include"); } set { Q("_source_include", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetScriptRequest : IRequest<GetScriptRequestParameters> 
	{
		Id Id { get; }
		Name Lang { get; }
	 } 
	///<summary>Request parameters for GetScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class GetScriptRequest  : RequestBase<GetScriptRequestParameters>, IGetScriptRequest
	{
		protected IGetScriptRequest Self => this;
		Id IGetScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IGetScriptRequest.Lang => Self.RouteValues.Get<Name>("lang");
			/// <summary>/_scripts/{lang}/{id}</summary>
///<param name="lang">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public GetScriptRequest(Name lang, Id id) : base(r=>r.Required("lang", lang).Required("id", id)){}
		

			///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetSearchTemplateRequest : IRequest<GetSearchTemplateRequestParameters> 
	{
		Id Id { get; }
	 } 
	///<summary>Request parameters for GetTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class GetSearchTemplateRequest  : RequestBase<GetSearchTemplateRequestParameters>, IGetSearchTemplateRequest
	{
		protected IGetSearchTemplateRequest Self => this;
		Id IGetSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_search/template/{id}</summary>
///<param name="id">this parameter is required</param>
		public GetSearchTemplateRequest(Id id) : base(r=>r.Required("id", id)){}
		

			///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetSnapshotRequest : IRequest<GetSnapshotRequestParameters> 
	{
		Name RepositoryName { get; }
		Names Snapshot { get; }
	 } 
	///<summary>Request parameters for SnapshotGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetSnapshotRequest  : RequestBase<GetSnapshotRequestParameters>, IGetSnapshotRequest
	{
		protected IGetSnapshotRequest Self => this;
		Name IGetSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names IGetSnapshotRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}</summary>
///<param name="repository">this parameter is required</param>		
///<param name="snapshot">this parameter is required</param>
		public GetSnapshotRequest(Name repository, Names snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IGetWarmerRequest : IRequest<GetWarmerRequestParameters> 
	{
		Indices Index { get; }
		Names Name { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for IndicesGetWarmerForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html</pre></summary>
	public partial class GetWarmerRequest  : RequestBase<GetWarmerRequestParameters>, IGetWarmerRequest
	{
		protected IGetWarmerRequest Self => this;
		Indices IGetWarmerRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetWarmerRequest.Name => Self.RouteValues.Get<Names>("name");
		Types IGetWarmerRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_warmer</summary>
		public GetWarmerRequest() : base(){}
		

		/// <summary>/{index}/_warmer</summary>
///<param name="index">Optional, accepts null</param>
		public GetWarmerRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/_warmer/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="name">Optional, accepts null</param>
		public GetWarmerRequest(Indices index, Names name) : base(r=>r.Optional("index", index).Optional("name", name)){}
		

		/// <summary>/_warmer/{name}</summary>
///<param name="name">Optional, accepts null</param>
		public GetWarmerRequest(Names name) : base(r=>r.Optional("name", name)){}
		

		/// <summary>/{index}/{type}/_warmer/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>		
///<param name="name">Optional, accepts null</param>
		public GetWarmerRequest(Indices index, Types type, Names name) : base(r=>r.Optional("index", index).Optional("type", type).Optional("name", name)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IIndexExistsRequest : IRequest<IndexExistsRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html</pre></summary>
	public partial class IndexExistsRequest  : RequestBase<IndexExistsRequestParameters>, IIndexExistsRequest
	{
		protected IIndexExistsRequest Self => this;
		Indices IIndexExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}</summary>
///<param name="index">this parameter is required</param>
		public IndexExistsRequest(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IIndexRequest<TDocument> : IRequest<IndexRequestParameters> 
	{
		Id Id { get; }
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Index <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class IndexRequest<TDocument>  : RequestBase<IndexRequestParameters>, IIndexRequest<TDocument>
	{
		protected IIndexRequest<TDocument> Self => this;
		Id IIndexRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IIndexRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IIndexRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>
		public IndexRequest(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}/{id}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">Optional, accepts null</param>
		public IndexRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Optional("id", id)){}
		

		/// <summary>/{index}/{type}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public IndexRequest(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>Explicit write consistency setting for the operation</summary>
		public Consistency Consistency { get { return Q<Consistency>("consistency"); } set { Q("consistency", value); } }
		
		///<summary>Explicit operation type</summary>
		public OpType OpType { get { return Q<OpType>("op_type"); } set { Q("op_type", value); } }
		
		///<summary>ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Refresh the index after performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Explicit timestamp for the document</summary>
		public string Timestamp { get { return Q<string>("timestamp"); } set { Q("timestamp", value); } }
		
		///<summary>Expiration time for the document</summary>
		public string Ttl { get { return Q<string>("ttl"); } set { Q("ttl", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IIndexTemplateExistsRequest : IRequest<IndexTemplateExistsRequestParameters> 
	{
		Name Name { get; }
	 } 
	///<summary>Request parameters for IndicesExistsTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class IndexTemplateExistsRequest  : RequestBase<IndexTemplateExistsRequestParameters>, IIndexTemplateExistsRequest
	{
		protected IIndexTemplateExistsRequest Self => this;
		Name IIndexTemplateExistsRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/_template/{name}</summary>
///<param name="name">this parameter is required</param>
		public IndexTemplateExistsRequest(Name name) : base(r=>r.Required("name", name)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IIndicesShardStoresRequest : IRequest<IndicesShardStoresRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesShardStoresForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shards-stores.html</pre></summary>
	public partial class IndicesShardStoresRequest  : RequestBase<IndicesShardStoresRequestParameters>, IIndicesShardStoresRequest
	{
		protected IIndicesShardStoresRequest Self => this;
		Indices IIndicesShardStoresRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_shard_stores</summary>
		public IndicesShardStoresRequest() : base(){}
		

		/// <summary>/{index}/_shard_stores</summary>
///<param name="index">Optional, accepts null</param>
		public IndicesShardStoresRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>A comma-separated list of statuses used to filter on shards to get store information for</summary>
		public  string[] Status { get { return Q< string[]>("status"); } set { Q("status", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>TODO: ?</summary>
		public string OperationThreading { get { return Q<string>("operation_threading"); } set { Q("operation_threading", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		//TODO THIS METHOD IS UNMAPPED!
	
	}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IIndicesStatsRequest : IRequest<IndicesStatsRequestParameters> 
	{
		Indices Index { get; }
		Metrics Metric { get; }
	 } 
	///<summary>Request parameters for IndicesStatsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html</pre></summary>
	public partial class IndicesStatsRequest  : RequestBase<IndicesStatsRequestParameters>, IIndicesStatsRequest
	{
		protected IIndicesStatsRequest Self => this;
		Indices IIndicesStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Metrics IIndicesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
			/// <summary>/_stats</summary>
		public IndicesStatsRequest() : base(){}
		

		/// <summary>/_stats/{metric}</summary>
///<param name="metric">Optional, accepts null</param>
		public IndicesStatsRequest(IndicesStatsMetric metric) : base(r=>r.Optional("metric", (Metrics)metric)){}
		

		/// <summary>/{index}/_stats</summary>
///<param name="index">Optional, accepts null</param>
		public IndicesStatsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/_stats/{metric}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="metric">Optional, accepts null</param>
		public IndicesStatsRequest(Indices index, IndicesStatsMetric metric) : base(r=>r.Optional("index", index).Optional("metric", (Metrics)metric)){}
		

			///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public FieldNames CompletionFields { get { return Q<FieldNames>("completion_fields"); } set { Q("completion_fields", value); } }
		
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public FieldNames FielddataFields { get { return Q<FieldNames>("fielddata_fields"); } set { Q("fielddata_fields", value); } }
		
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public  string[] Groups { get { return Q< string[]>("groups"); } set { Q("groups", value); } }
		
		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>Return stats aggregated at cluster, index or shard level</summary>
		public Level Level { get { return Q<Level>("level"); } set { Q("level", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IMultiGetRequest : IRequest<MultiGetRequestParameters> 
	{
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Mget <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html</pre></summary>
	public partial class MultiGetRequest  : RequestBase<MultiGetRequestParameters>, IMultiGetRequest
	{
		protected IMultiGetRequest Self => this;
		IndexName IMultiGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiGetRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_mget</summary>
		public MultiGetRequest() : base(){}
		

		/// <summary>/{index}/_mget</summary>
///<param name="index">Optional, accepts null</param>
		public MultiGetRequest(IndexName index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_mget</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public MultiGetRequest(IndexName index, TypeName type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>A comma-separated list of fields to return in the response</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public  string[] SourceEnabled { get { return Q< string[]>("_source"); } set { Q("_source", value); } }
		
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public FieldNames SourceExclude { get { return Q<FieldNames>("_source_exclude"); } set { Q("_source_exclude", value); } }
		
		///<summary>A list of fields to extract and return from the _source field</summary>
		public FieldNames SourceInclude { get { return Q<FieldNames>("_source_include"); } set { Q("_source_include", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IMultiPercolateRequest : IRequest<MultiPercolateRequestParameters> 
	{
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Mpercolate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html</pre></summary>
	public partial class MultiPercolateRequest  : RequestBase<MultiPercolateRequestParameters>, IMultiPercolateRequest
	{
		protected IMultiPercolateRequest Self => this;
		IndexName IMultiPercolateRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiPercolateRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_mpercolate</summary>
		public MultiPercolateRequest() : base(){}
		

		/// <summary>/{index}/_mpercolate</summary>
///<param name="index">Optional, accepts null</param>
		public MultiPercolateRequest(IndexName index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_mpercolate</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public MultiPercolateRequest(IndexName index, TypeName type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IMultiSearchRequest : IRequest<MultiSearchRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for Msearch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html</pre></summary>
	public partial class MultiSearchRequest  : RequestBase<MultiSearchRequestParameters>, IMultiSearchRequest
	{
		protected IMultiSearchRequest Self => this;
		Indices IMultiSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IMultiSearchRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_msearch</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public MultiSearchRequest() {}
		

		/// <summary>/{index}/_msearch</summary>
///<param name="index">Optional, accepts null</param>
		public MultiSearchRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_msearch</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public MultiSearchRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Search operation type</summary>
		public SearchType SearchType { get { return Q<SearchType>("search_type"); } set { Q("search_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IMultiTermVectorsRequest : IRequest<MultiTermVectorsRequestParameters> 
	{
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Mtermvectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html</pre></summary>
	public partial class MultiTermVectorsRequest  : RequestBase<MultiTermVectorsRequestParameters>, IMultiTermVectorsRequest
	{
		protected IMultiTermVectorsRequest Self => this;
		IndexName IMultiTermVectorsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiTermVectorsRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_mtermvectors</summary>
		public MultiTermVectorsRequest() : base(){}
		

		/// <summary>/{index}/_mtermvectors</summary>
///<param name="index">Optional, accepts null</param>
		public MultiTermVectorsRequest(IndexName index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_mtermvectors</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public MultiTermVectorsRequest(IndexName index, TypeName type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public bool TermStatistics { get { return Q<bool>("term_statistics"); } set { Q("term_statistics", value); } }
		
		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public bool FieldStatistics { get { return Q<bool>("field_statistics"); } set { Q("field_statistics", value); } }
		
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public bool Offsets { get { return Q<bool>("offsets"); } set { Q("offsets", value); } }
		
		///<summary>Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public bool Positions { get { return Q<bool>("positions"); } set { Q("positions", value); } }
		
		///<summary>Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public bool Payloads { get { return Q<bool>("payloads"); } set { Q("payloads", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Parent id of documents. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specifies if requests are real-time as opposed to near-real-time (default: true).</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface INodesHotThreadsRequest : IRequest<NodesHotThreadsRequestParameters> 
	{
		NodeIds NodeId { get; }
	 } 
	///<summary>Request parameters for NodesHotThreadsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-hot-threads.html</pre></summary>
	public partial class NodesHotThreadsRequest  : RequestBase<NodesHotThreadsRequestParameters>, INodesHotThreadsRequest
	{
		protected INodesHotThreadsRequest Self => this;
		NodeIds INodesHotThreadsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_cluster/nodes/hotthreads</summary>
		public NodesHotThreadsRequest() : base(){}
		

		/// <summary>/_cluster/nodes/{node_id}/hotthreads</summary>
///<param name="node_id">Optional, accepts null</param>
		public NodesHotThreadsRequest(NodeIds node_id) : base(r=>r.Optional("node_id", node_id)){}
		

			///<summary>The interval for the second sampling of threads</summary>
		public string Interval { get { return Q<string>("interval"); } set { Q("interval", value); } }
		
		///<summary>Number of samples of thread stacktrace (default: 10)</summary>
		public long Snapshots { get { return Q<long>("snapshots"); } set { Q("snapshots", value); } }
		
		///<summary>Specify the number of threads to provide information for (default: 3)</summary>
		public long Threads { get { return Q<long>("threads"); } set { Q("threads", value); } }
		
		///<summary>Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)</summary>
		public bool IgnoreIdleThreads { get { return Q<bool>("ignore_idle_threads"); } set { Q("ignore_idle_threads", value); } }
		
		///<summary>The type to sample (default: cpu)</summary>
		public ThreadType ThreadType { get { return Q<ThreadType>("type"); } set { Q("type", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface INodesInfoRequest : IRequest<NodesInfoRequestParameters> 
	{
		NodeIds NodeId { get; }
		Metrics Metric { get; }
	 } 
	///<summary>Request parameters for NodesInfoForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-info.html</pre></summary>
	public partial class NodesInfoRequest  : RequestBase<NodesInfoRequestParameters>, INodesInfoRequest
	{
		protected INodesInfoRequest Self => this;
		NodeIds INodesInfoRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		Metrics INodesInfoRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
			/// <summary>/_nodes</summary>
		public NodesInfoRequest() : base(){}
		

		/// <summary>/_nodes/{node_id}</summary>
///<param name="node_id">Optional, accepts null</param>
		public NodesInfoRequest(NodeIds node_id) : base(r=>r.Optional("node_id", node_id)){}
		

		/// <summary>/_nodes/{metric}</summary>
///<param name="metric">Optional, accepts null</param>
		public NodesInfoRequest(NodesInfoMetric metric) : base(r=>r.Optional("metric", (Metrics)metric)){}
		

		/// <summary>/_nodes/{node_id}/{metric}</summary>
///<param name="node_id">Optional, accepts null</param>		
///<param name="metric">Optional, accepts null</param>
		public NodesInfoRequest(NodeIds node_id, NodesInfoMetric metric) : base(r=>r.Optional("node_id", node_id).Optional("metric", (Metrics)metric)){}
		

			///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface INodesStatsRequest : IRequest<NodesStatsRequestParameters> 
	{
		Metrics Metric { get; }
		IndexMetrics IndexMetric { get; }
		NodeIds NodeId { get; }
	 } 
	///<summary>Request parameters for NodesStatsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-stats.html</pre></summary>
	public partial class NodesStatsRequest  : RequestBase<NodesStatsRequestParameters>, INodesStatsRequest
	{
		protected INodesStatsRequest Self => this;
		Metrics INodesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		IndexMetrics INodesStatsRequest.IndexMetric => Self.RouteValues.Get<IndexMetrics>("index_metric");
		NodeIds INodesStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_nodes/stats</summary>
		public NodesStatsRequest() : base(){}
		

		/// <summary>/_nodes/{node_id}/stats</summary>
///<param name="node_id">Optional, accepts null</param>
		public NodesStatsRequest(NodeIds node_id) : base(r=>r.Optional("node_id", node_id)){}
		

		/// <summary>/_nodes/stats/{metric}</summary>
///<param name="metric">Optional, accepts null</param>
		public NodesStatsRequest(NodesStatsMetric metric) : base(r=>r.Optional("metric", (Metrics)metric)){}
		

		/// <summary>/_nodes/{node_id}/stats/{metric}</summary>
///<param name="node_id">Optional, accepts null</param>		
///<param name="metric">Optional, accepts null</param>
		public NodesStatsRequest(NodeIds node_id, NodesStatsMetric metric) : base(r=>r.Optional("node_id", node_id).Optional("metric", (Metrics)metric)){}
		

		/// <summary>/_nodes/stats/{metric}/{index_metric}</summary>
///<param name="metric">Optional, accepts null</param>		
///<param name="index_metric">Optional, accepts null</param>
		public NodesStatsRequest(NodesStatsMetric metric, NodesStatsIndexMetric index_metric) : base(r=>r.Optional("metric", (Metrics)metric).Optional("index_metric", (IndexMetrics)index_metric)){}
		

		/// <summary>/_nodes/{node_id}/stats/{metric}/{index_metric}</summary>
///<param name="node_id">Optional, accepts null</param>		
///<param name="metric">Optional, accepts null</param>		
///<param name="index_metric">Optional, accepts null</param>
		public NodesStatsRequest(NodeIds node_id, NodesStatsMetric metric, NodesStatsIndexMetric index_metric) : base(r=>r.Optional("node_id", node_id).Optional("metric", (Metrics)metric).Optional("index_metric", (IndexMetrics)index_metric)){}
		

			///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public FieldNames CompletionFields { get { return Q<FieldNames>("completion_fields"); } set { Q("completion_fields", value); } }
		
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public FieldNames FielddataFields { get { return Q<FieldNames>("fielddata_fields"); } set { Q("fielddata_fields", value); } }
		
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public bool Groups { get { return Q<bool>("groups"); } set { Q("groups", value); } }
		
		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>Return indices stats aggregated at node, index or shard level</summary>
		public Level Level { get { return Q<Level>("level"); } set { Q("level", value); } }
		
		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public  string[] Types { get { return Q< string[]>("types"); } set { Q("types", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IOpenIndexRequest : IRequest<OpenIndexRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesOpen <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class OpenIndexRequest  : RequestBase<OpenIndexRequestParameters>, IOpenIndexRequest
	{
		protected IOpenIndexRequest Self => this;
		Indices IOpenIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}/_open</summary>
///<param name="index">this parameter is required</param>
		public OpenIndexRequest(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IOptimizeRequest : IRequest<OptimizeRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesOptimizeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-optimize.html</pre></summary>
	public partial class OptimizeRequest  : RequestBase<OptimizeRequestParameters>, IOptimizeRequest
	{
		protected IOptimizeRequest Self => this;
		Indices IOptimizeRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_optimize</summary>
		public OptimizeRequest() : base(){}
		

		/// <summary>/{index}/_optimize</summary>
///<param name="index">Optional, accepts null</param>
		public OptimizeRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Specify whether the index should be flushed after performing the operation (default: true)</summary>
		public bool Flush { get { return Q<bool>("flush"); } set { Q("flush", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The number of segments the index should be merged into (default: dynamic)</summary>
		public long MaxNumSegments { get { return Q<long>("max_num_segments"); } set { Q("max_num_segments", value); } }
		
		///<summary>Specify whether the operation should only expunge deleted documents</summary>
		public bool OnlyExpungeDeletes { get { return Q<bool>("only_expunge_deletes"); } set { Q("only_expunge_deletes", value); } }
		
		///<summary>TODO: ?</summary>
		public string OperationThreading { get { return Q<string>("operation_threading"); } set { Q("operation_threading", value); } }
		
		///<summary>Specify whether the request should block until the merge process is finished (default: true)</summary>
		public bool WaitForMerge { get { return Q<bool>("wait_for_merge"); } set { Q("wait_for_merge", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPercolateCountRequest<TDocument> : IRequest<PercolateCountRequestParameters> 
	{
		IndexName Index { get; }
		TypeName Type { get; }
		Id Id { get; }
	 } 
	///<summary>Request parameters for CountPercolate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html</pre></summary>
	public partial class PercolateCountRequest<TDocument>  : RequestBase<PercolateCountRequestParameters>, IPercolateCountRequest<TDocument>
	{
		protected IPercolateCountRequest<TDocument> Self => this;
		IndexName IPercolateCountRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IPercolateCountRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
		Id IPercolateCountRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/{index}/{type}/_percolate/count</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>
		public PercolateCountRequest(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}/{id}/_percolate/count</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">Optional, accepts null</param>
		public PercolateCountRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Optional("id", id)){}
		

		/// <summary>/{index}/{type}/_percolate/count</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public PercolateCountRequest(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>A comma-separated list of specific routing values</summary>
		public  string[] Routing { get { return Q< string[]>("routing"); } set { Q("routing", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The index to count percolate the document into. Defaults to index.</summary>
		public string PercolateIndex { get { return Q<string>("percolate_index"); } set { Q("percolate_index", value); } }
		
		///<summary>The type to count percolate document into. Defaults to type.</summary>
		public string PercolateType { get { return Q<string>("percolate_type"); } set { Q("percolate_type", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPercolateRequest<TDocument> : IRequest<PercolateRequestParameters> 
	{
		IndexName Index { get; }
		TypeName Type { get; }
		Id Id { get; }
	 } 
	///<summary>Request parameters for Percolate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html</pre></summary>
	public partial class PercolateRequest<TDocument>  : RequestBase<PercolateRequestParameters>, IPercolateRequest<TDocument>
	{
		protected IPercolateRequest<TDocument> Self => this;
		IndexName IPercolateRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IPercolateRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
		Id IPercolateRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/{index}/{type}/_percolate</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>
		public PercolateRequest(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}/{id}/_percolate</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">Optional, accepts null</param>
		public PercolateRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Optional("id", id)){}
		

		/// <summary>/{index}/{type}/_percolate</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public PercolateRequest(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>A comma-separated list of specific routing values</summary>
		public  string[] Routing { get { return Q< string[]>("routing"); } set { Q("routing", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The index to percolate the document into. Defaults to index.</summary>
		public string PercolateIndex { get { return Q<string>("percolate_index"); } set { Q("percolate_index", value); } }
		
		///<summary>The type to percolate document into. Defaults to type.</summary>
		public string PercolateType { get { return Q<string>("percolate_type"); } set { Q("percolate_type", value); } }
		
		///<summary>The routing value to use when percolating the existing document.</summary>
		public string PercolateRouting { get { return Q<string>("percolate_routing"); } set { Q("percolate_routing", value); } }
		
		///<summary>Which shard to prefer when executing the percolate request.</summary>
		public string PercolatePreference { get { return Q<string>("percolate_preference"); } set { Q("percolate_preference", value); } }
		
		///<summary>Return an array of matching query IDs instead of objects</summary>
		public PercolateFormat PercolateFormat { get { return Q<PercolateFormat>("percolate_format"); } set { Q("percolate_format", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPingRequest : IRequest<PingRequestParameters> 
	{
	 } 
	///<summary>Request parameters for Ping <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class PingRequest  : RequestBase<PingRequestParameters>, IPingRequest
	{
		protected IPingRequest Self => this;
				///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPutAliasRequest : IRequest<PutAliasRequestParameters> 
	{
		Indices Index { get; }
		Name Name { get; }
	 } 
	///<summary>Request parameters for IndicesPutAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class PutAliasRequest  : RequestBase<PutAliasRequestParameters>, IPutAliasRequest
	{
		protected IPutAliasRequest Self => this;
		Indices IPutAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Name IPutAliasRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/{index}/_alias/{name}</summary>
///<param name="index">this parameter is required</param>		
///<param name="name">this parameter is required</param>
		public PutAliasRequest(Indices index, Name name) : base(r=>r.Required("index", index).Required("name", name)){}
		

			///<summary>Explicit timestamp for the document</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPutIndexTemplateRequest : IRequest<PutIndexTemplateRequestParameters> 
	{
		Name Name { get; }
	 } 
	///<summary>Request parameters for IndicesPutTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class PutIndexTemplateRequest  : RequestBase<PutIndexTemplateRequestParameters>, IPutIndexTemplateRequest
	{
		protected IPutIndexTemplateRequest Self => this;
		Name IPutIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/_template/{name}</summary>
///<param name="name">this parameter is required</param>
		public PutIndexTemplateRequest(Name name) : base(r=>r.Required("name", name)){}
		

			///<summary>Whether the index template should only be added if new or can also replace an existing one</summary>
		public bool Create { get { return Q<bool>("create"); } set { Q("create", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPutMappingRequest : IRequest<PutMappingRequestParameters> 
	{
		Indices Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for IndicesPutMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html</pre></summary>
	public partial class PutMappingRequest<T>  : RequestBase<PutMappingRequestParameters>, IPutMappingRequest
	{
		protected IPutMappingRequest Self => this;
		Indices IPutMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		TypeName IPutMappingRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/_mapping</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">this parameter is required</param>
		public PutMappingRequest(Indices index, TypeName type) : base(r=>r.Optional("index", index).Required("type", type)){}
		

		/// <summary>/_mapping/{type}</summary>
///<param name="type">this parameter is required</param>
		public PutMappingRequest(TypeName type) : base(r=>r.Required("type", type)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Whether to update the mapping for all fields with the same name across all types or not</summary>
		public bool UpdateAllTypes { get { return Q<bool>("update_all_types"); } set { Q("update_all_types", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for IndicesPutMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html</pre></summary>
	public partial class PutMappingRequest  : RequestBase<PutMappingRequestParameters>, IPutMappingRequest
	{
		protected IPutMappingRequest Self => this;
		Indices IPutMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		TypeName IPutMappingRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/_mapping</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">this parameter is required</param>
		public PutMappingRequest(Indices index, TypeName type) : base(r=>r.Optional("index", index).Required("type", type)){}
		

		/// <summary>/_mapping/{type}</summary>
///<param name="type">this parameter is required</param>
		public PutMappingRequest(TypeName type) : base(r=>r.Required("type", type)){}
		

			///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Whether to update the mapping for all fields with the same name across all types or not</summary>
		public bool UpdateAllTypes { get { return Q<bool>("update_all_types"); } set { Q("update_all_types", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPutScriptRequest : IRequest<PutScriptRequestParameters> 
	{
		Id Id { get; }
		Name Lang { get; }
	 } 
	///<summary>Request parameters for PutScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class PutScriptRequest  : RequestBase<PutScriptRequestParameters>, IPutScriptRequest
	{
		protected IPutScriptRequest Self => this;
		Id IPutScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IPutScriptRequest.Lang => Self.RouteValues.Get<Name>("lang");
			/// <summary>/_scripts/{lang}/{id}</summary>
///<param name="lang">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public PutScriptRequest(Name lang, Id id) : base(r=>r.Required("lang", lang).Required("id", id)){}
		

			///<summary>Explicit operation type</summary>
		public OpType OpType { get { return Q<OpType>("op_type"); } set { Q("op_type", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPutSearchTemplateRequest : IRequest<PutSearchTemplateRequestParameters> 
	{
		Id Id { get; }
	 } 
	///<summary>Request parameters for PutTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class PutSearchTemplateRequest  : RequestBase<PutSearchTemplateRequestParameters>, IPutSearchTemplateRequest
	{
		protected IPutSearchTemplateRequest Self => this;
		Id IPutSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_search/template/{id}</summary>
///<param name="id">this parameter is required</param>
		public PutSearchTemplateRequest(Id id) : base(r=>r.Required("id", id)){}
		

			///<summary>Explicit operation type</summary>
		public OpType OpType { get { return Q<OpType>("op_type"); } set { Q("op_type", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IPutWarmerRequest : IRequest<PutWarmerRequestParameters> 
	{
		Indices Index { get; }
		Name Name { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for IndicesPutWarmerForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html</pre></summary>
	public partial class PutWarmerRequest  : RequestBase<PutWarmerRequestParameters>, IPutWarmerRequest
	{
		protected IPutWarmerRequest Self => this;
		Indices IPutWarmerRequest.Index => Self.RouteValues.Get<Indices>("index");
		Name IPutWarmerRequest.Name => Self.RouteValues.Get<Name>("name");
		Types IPutWarmerRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_warmer/{name}</summary>
///<param name="name">this parameter is required</param>
		public PutWarmerRequest(Name name) : base(r=>r.Required("name", name)){}
		

		/// <summary>/{index}/_warmer/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="name">this parameter is required</param>
		public PutWarmerRequest(Indices index, Name name) : base(r=>r.Optional("index", index).Required("name", name)){}
		

		/// <summary>/{index}/{type}/_warmer/{name}</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>		
///<param name="name">this parameter is required</param>
		public PutWarmerRequest(Indices index, Types type, Name name) : base(r=>r.Optional("index", index).Optional("type", type).Required("name", name)){}
		

			///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Specify whether the request to be warmed should use the request cache, defaults to index level setting</summary>
		public bool RequestCache { get { return Q<bool>("request_cache"); } set { Q("request_cache", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IRecoveryStatusRequest : IRequest<RecoveryStatusRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesRecoveryForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html</pre></summary>
	public partial class RecoveryStatusRequest  : RequestBase<RecoveryStatusRequestParameters>, IRecoveryStatusRequest
	{
		protected IRecoveryStatusRequest Self => this;
		Indices IRecoveryStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_recovery</summary>
		public RecoveryStatusRequest() : base(){}
		

		/// <summary>/{index}/_recovery</summary>
///<param name="index">Optional, accepts null</param>
		public RecoveryStatusRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether to display detailed information about shard recovery</summary>
		public bool Detailed { get { return Q<bool>("detailed"); } set { Q("detailed", value); } }
		
		///<summary>Display only those recoveries that are currently on-going</summary>
		public bool ActiveOnly { get { return Q<bool>("active_only"); } set { Q("active_only", value); } }
		
		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IRefreshRequest : IRequest<RefreshRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesRefreshForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-refresh.html</pre></summary>
	public partial class RefreshRequest  : RequestBase<RefreshRequestParameters>, IRefreshRequest
	{
		protected IRefreshRequest Self => this;
		Indices IRefreshRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_refresh</summary>
		public RefreshRequest() : base(){}
		

		/// <summary>/{index}/_refresh</summary>
///<param name="index">Optional, accepts null</param>
		public RefreshRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Force a refresh even if not required</summary>
		public bool Force { get { return Q<bool>("force"); } set { Q("force", value); } }
		
		///<summary>TODO: ?</summary>
		public string OperationThreading { get { return Q<string>("operation_threading"); } set { Q("operation_threading", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IRenderSearchTemplateRequest : IRequest<RenderSearchTemplateRequestParameters> 
	{
		Id Id { get; }
	 } 
	///<summary>Request parameters for RenderSearchTemplate <pre>http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class RenderSearchTemplateRequest  : RequestBase<RenderSearchTemplateRequestParameters>, IRenderSearchTemplateRequest
	{
		protected IRenderSearchTemplateRequest Self => this;
		Id IRenderSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_render/template</summary>
		public RenderSearchTemplateRequest() : base(){}
		

		/// <summary>/_render/template/{id}</summary>
///<param name="id">Optional, accepts null</param>
		public RenderSearchTemplateRequest(Id id) : base(r=>r.Optional("id", id)){}
		

			///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		//TODO THIS METHOD IS UNMAPPED!
	
	}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IRestoreRequest : IRequest<RestoreRequestParameters> 
	{
		Name RepositoryName { get; }
		Name Snapshot { get; }
	 } 
	///<summary>Request parameters for SnapshotRestore <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class RestoreRequest  : RequestBase<RestoreRequestParameters>, IRestoreRequest
	{
		protected IRestoreRequest Self => this;
		Name IRestoreRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IRestoreRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}/_restore</summary>
///<param name="repository">this parameter is required</param>		
///<param name="snapshot">this parameter is required</param>
		public RestoreRequest(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public bool WaitForCompletion { get { return Q<bool>("wait_for_completion"); } set { Q("wait_for_completion", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IRootNodeInfoRequest : IRequest<RootNodeInfoRequestParameters> 
	{
	 } 
	///<summary>Request parameters for Info <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class RootNodeInfoRequest  : RequestBase<RootNodeInfoRequestParameters>, IRootNodeInfoRequest
	{
		protected IRootNodeInfoRequest Self => this;
				///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IScrollRequest : IRequest<ScrollRequestParameters> 
	{
		ScrollId ScrollId { get; }
	 } 
	///<summary>Request parameters for Scroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ScrollRequest  : RequestBase<ScrollRequestParameters>, IScrollRequest
	{
		protected IScrollRequest Self => this;
		ScrollId IScrollRequest.ScrollId => Self.RouteValues.Get<ScrollId>("scroll_id");
			/// <summary>/_search/scroll</summary>
		public ScrollRequest() : base(){}
		

		/// <summary>/_search/scroll/{scroll_id}</summary>
///<param name="scroll_id">Optional, accepts null</param>
		public ScrollRequest(ScrollId scroll_id) : base(r=>r.Optional("scroll_id", scroll_id)){}
		

			///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISearchExistsRequest : IRequest<SearchExistsRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for SearchExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-exists.html</pre></summary>
	public partial class SearchExistsRequest<T>  : RequestBase<SearchExistsRequestParameters>, ISearchExistsRequest
	{
		protected ISearchExistsRequest Self => this;
		Indices ISearchExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchExistsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search/exists</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SearchExistsRequest() : this(typeof(T), typeof(T)) {}
		

		/// <summary>/{index}/_search/exists</summary>
///<param name="index">Optional, accepts null</param>
		public SearchExistsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_search/exists</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public SearchExistsRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public double MinScore { get { return Q<double>("min_score"); } set { Q("min_score", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for SearchExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-exists.html</pre></summary>
	public partial class SearchExistsRequest  : RequestBase<SearchExistsRequestParameters>, ISearchExistsRequest
	{
		protected ISearchExistsRequest Self => this;
		Indices ISearchExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchExistsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search/exists</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SearchExistsRequest() {}
		

		/// <summary>/{index}/_search/exists</summary>
///<param name="index">Optional, accepts null</param>
		public SearchExistsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_search/exists</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public SearchExistsRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public double MinScore { get { return Q<double>("min_score"); } set { Q("min_score", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISearchRequest : IRequest<SearchRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for Search <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html</pre></summary>
	public partial class SearchRequest<T>  : RequestBase<SearchRequestParameters>, ISearchRequest
	{
		protected ISearchRequest Self => this;
		Indices ISearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SearchRequest() : this(typeof(T), typeof(T)) {}
		

		/// <summary>/{index}/_search</summary>
///<param name="index">Optional, accepts null</param>
		public SearchRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_search</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public SearchRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>A comma-separated list of specific routing values</summary>
		public  string[] Routing { get { return Q< string[]>("routing"); } set { Q("routing", value); } }
		
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public string Scroll { get { return Q<string>("scroll"); } set { Q("scroll", value); } }
		
		///<summary>Search operation type</summary>
		public SearchType SearchType { get { return Q<SearchType>("search_type"); } set { Q("search_type", value); } }
		
		///<summary>Specific &#39;tag&#39; of the request for logging and statistical purposes</summary>
		public  string[] Stats { get { return Q< string[]>("stats"); } set { Q("stats", value); } }
		
		///<summary>Specify which field to use for suggestions</summary>
		public FieldName SuggestField { get { return Q<FieldName>("suggest_field"); } set { Q("suggest_field", value); } }
		
		///<summary>Specify suggest mode</summary>
		public SuggestMode SuggestMode { get { return Q<SuggestMode>("suggest_mode"); } set { Q("suggest_mode", value); } }
		
		///<summary>How many suggestions to return in response</summary>
		public long SuggestSize { get { return Q<long>("suggest_size"); } set { Q("suggest_size", value); } }
		
		///<summary>The source text for which the suggestions should be returned</summary>
		public string SuggestText { get { return Q<string>("suggest_text"); } set { Q("suggest_text", value); } }
		
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public bool RequestCache { get { return Q<bool>("request_cache"); } set { Q("request_cache", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for Search <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html</pre></summary>
	public partial class SearchRequest  : RequestBase<SearchRequestParameters>, ISearchRequest
	{
		protected ISearchRequest Self => this;
		Indices ISearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SearchRequest() {}
		

		/// <summary>/{index}/_search</summary>
///<param name="index">Optional, accepts null</param>
		public SearchRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_search</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public SearchRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>A comma-separated list of specific routing values</summary>
		public  string[] Routing { get { return Q< string[]>("routing"); } set { Q("routing", value); } }
		
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public string Scroll { get { return Q<string>("scroll"); } set { Q("scroll", value); } }
		
		///<summary>Search operation type</summary>
		public SearchType SearchType { get { return Q<SearchType>("search_type"); } set { Q("search_type", value); } }
		
		///<summary>Specific &#39;tag&#39; of the request for logging and statistical purposes</summary>
		public  string[] Stats { get { return Q< string[]>("stats"); } set { Q("stats", value); } }
		
		///<summary>Specify which field to use for suggestions</summary>
		public FieldName SuggestField { get { return Q<FieldName>("suggest_field"); } set { Q("suggest_field", value); } }
		
		///<summary>Specify suggest mode</summary>
		public SuggestMode SuggestMode { get { return Q<SuggestMode>("suggest_mode"); } set { Q("suggest_mode", value); } }
		
		///<summary>How many suggestions to return in response</summary>
		public long SuggestSize { get { return Q<long>("suggest_size"); } set { Q("suggest_size", value); } }
		
		///<summary>The source text for which the suggestions should be returned</summary>
		public string SuggestText { get { return Q<string>("suggest_text"); } set { Q("suggest_text", value); } }
		
		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public bool RequestCache { get { return Q<bool>("request_cache"); } set { Q("request_cache", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISearchShardsRequest : IRequest<SearchShardsRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for SearchShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html</pre></summary>
	public partial class SearchShardsRequest<T>  : RequestBase<SearchShardsRequestParameters>, ISearchShardsRequest
	{
		protected ISearchShardsRequest Self => this;
		Indices ISearchShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchShardsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/{type}/_search_shards</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SearchShardsRequest() : this(typeof(T), typeof(T)) {}
		

		/// <summary>/{index}/_search_shards</summary>
///<param name="index">Optional, accepts null</param>
		public SearchShardsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_search_shards</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public SearchShardsRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for SearchShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html</pre></summary>
	public partial class SearchShardsRequest  : RequestBase<SearchShardsRequestParameters>, ISearchShardsRequest
	{
		protected ISearchShardsRequest Self => this;
		Indices ISearchShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchShardsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/{type}/_search_shards</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SearchShardsRequest() {}
		

		/// <summary>/{index}/_search_shards</summary>
///<param name="index">Optional, accepts null</param>
		public SearchShardsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_search_shards</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public SearchShardsRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISearchTemplateRequest : IRequest<SearchTemplateRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for SearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</pre></summary>
	public partial class SearchTemplateRequest  : RequestBase<SearchTemplateRequestParameters>, ISearchTemplateRequest
	{
		protected ISearchTemplateRequest Self => this;
		Indices ISearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchTemplateRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search/template</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SearchTemplateRequest() {}
		

		/// <summary>/{index}/_search/template</summary>
///<param name="index">Optional, accepts null</param>
		public SearchTemplateRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_search/template</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public SearchTemplateRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>A comma-separated list of specific routing values</summary>
		public  string[] Routing { get { return Q< string[]>("routing"); } set { Q("routing", value); } }
		
		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public string Scroll { get { return Q<string>("scroll"); } set { Q("scroll", value); } }
		
		///<summary>Search operation type</summary>
		public SearchType SearchType { get { return Q<SearchType>("search_type"); } set { Q("search_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISegmentsRequest : IRequest<SegmentsRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesSegmentsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-segments.html</pre></summary>
	public partial class SegmentsRequest  : RequestBase<SegmentsRequestParameters>, ISegmentsRequest
	{
		protected ISegmentsRequest Self => this;
		Indices ISegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_segments</summary>
		public SegmentsRequest() : base(){}
		

		/// <summary>/{index}/_segments</summary>
///<param name="index">Optional, accepts null</param>
		public SegmentsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>TODO: ?</summary>
		public string OperationThreading { get { return Q<string>("operation_threading"); } set { Q("operation_threading", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISnapshotRequest : IRequest<SnapshotRequestParameters> 
	{
		Name RepositoryName { get; }
		Name Snapshot { get; }
	 } 
	///<summary>Request parameters for SnapshotCreate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotRequest  : RequestBase<SnapshotRequestParameters>, ISnapshotRequest
	{
		protected ISnapshotRequest Self => this;
		Name ISnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name ISnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}</summary>
///<param name="repository">this parameter is required</param>		
///<param name="snapshot">this parameter is required</param>
		public SnapshotRequest(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Should this request wait until the operation has completed before returning</summary>
		public bool WaitForCompletion { get { return Q<bool>("wait_for_completion"); } set { Q("wait_for_completion", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISnapshotStatusRequest : IRequest<SnapshotStatusRequestParameters> 
	{
		Name RepositoryName { get; }
		Names Snapshot { get; }
	 } 
	///<summary>Request parameters for SnapshotStatus <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotStatusRequest  : RequestBase<SnapshotStatusRequestParameters>, ISnapshotStatusRequest
	{
		protected ISnapshotStatusRequest Self => this;
		Name ISnapshotStatusRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names ISnapshotStatusRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
			/// <summary>/_snapshot/_status</summary>
		public SnapshotStatusRequest() : base(){}
		

		/// <summary>/_snapshot/{repository}/_status</summary>
///<param name="repository">Optional, accepts null</param>
		public SnapshotStatusRequest(Name repository) : base(r=>r.Optional("repository", repository)){}
		

		/// <summary>/_snapshot/{repository}/{snapshot}/_status</summary>
///<param name="repository">Optional, accepts null</param>		
///<param name="snapshot">Optional, accepts null</param>
		public SnapshotStatusRequest(Name repository, Names snapshot) : base(r=>r.Optional("repository", repository).Optional("snapshot", snapshot)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISourceRequest : IRequest<SourceRequestParameters> 
	{
		Id Id { get; }
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for GetSource <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceRequest<T>  : RequestBase<SourceRequestParameters>, ISourceRequest
	{
		protected ISourceRequest Self => this;
		Id ISourceRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName ISourceRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ISourceRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}/_source</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public SourceRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}/_source</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SourceRequest(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>The ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public  string[] SourceEnabled { get { return Q< string[]>("_source"); } set { Q("_source", value); } }
		
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public FieldNames SourceExclude { get { return Q<FieldNames>("_source_exclude"); } set { Q("_source_exclude", value); } }
		
		///<summary>A list of fields to extract and return from the _source field</summary>
		public FieldNames SourceInclude { get { return Q<FieldNames>("_source_include"); } set { Q("_source_include", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for GetSource <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceRequest  : RequestBase<SourceRequestParameters>, ISourceRequest
	{
		protected ISourceRequest Self => this;
		Id ISourceRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName ISourceRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ISourceRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}/_source</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public SourceRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

			///<summary>The ID of the parent document</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public  string[] SourceEnabled { get { return Q< string[]>("_source"); } set { Q("_source", value); } }
		
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public FieldNames SourceExclude { get { return Q<FieldNames>("_source_exclude"); } set { Q("_source_exclude", value); } }
		
		///<summary>A list of fields to extract and return from the _source field</summary>
		public FieldNames SourceInclude { get { return Q<FieldNames>("_source_include"); } set { Q("_source_include", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISuggestRequest : IRequest<SuggestRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for Suggest <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-suggesters.html</pre></summary>
	public partial class SuggestRequest  : RequestBase<SuggestRequestParameters>, ISuggestRequest
	{
		protected ISuggestRequest Self => this;
		Indices ISuggestRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_suggest</summary>
		public SuggestRequest() : base(){}
		

		/// <summary>/{index}/_suggest</summary>
///<param name="index">Optional, accepts null</param>
		public SuggestRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ISyncedFlushRequest : IRequest<SyncedFlushRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesFlushSyncedForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html</pre></summary>
	public partial class SyncedFlushRequest  : RequestBase<SyncedFlushRequestParameters>, ISyncedFlushRequest
	{
		protected ISyncedFlushRequest Self => this;
		Indices ISyncedFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_flush/synced</summary>
		public SyncedFlushRequest() : base(){}
		

		/// <summary>/{index}/_flush/synced</summary>
///<param name="index">Optional, accepts null</param>
		public SyncedFlushRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ITermVectorsRequest<TDocument> : IRequest<TermVectorsRequestParameters> 
	{
		IndexName Index { get; }
		TypeName Type { get; }
		Id Id { get; }
	 } 
	///<summary>Request parameters for Termvectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html</pre></summary>
	public partial class TermVectorsRequest<TDocument>  : RequestBase<TermVectorsRequestParameters>, ITermVectorsRequest<TDocument>
	{
		protected ITermVectorsRequest<TDocument> Self => this;
		IndexName ITermVectorsRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ITermVectorsRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
		Id ITermVectorsRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/{index}/{type}/_termvectors</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>
		public TermVectorsRequest(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}/{id}/_termvectors</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">Optional, accepts null</param>
		public TermVectorsRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Optional("id", id)){}
		

		/// <summary>/{index}/{type}/_termvectors</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public TermVectorsRequest(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>Specifies if total term frequency and document frequency should be returned.</summary>
		public bool TermStatistics { get { return Q<bool>("term_statistics"); } set { Q("term_statistics", value); } }
		
		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.</summary>
		public bool FieldStatistics { get { return Q<bool>("field_statistics"); } set { Q("field_statistics", value); } }
		
		///<summary>Specifies if distributed frequencies should be returned instead shard frequencies.</summary>
		public bool Dfs { get { return Q<bool>("dfs"); } set { Q("dfs", value); } }
		
		///<summary>A comma-separated list of fields to return.</summary>
		public FieldNames Fields { get { return Q<FieldNames>("fields"); } set { Q("fields", value); } }
		
		///<summary>Specifies if term offsets should be returned.</summary>
		public bool Offsets { get { return Q<bool>("offsets"); } set { Q("offsets", value); } }
		
		///<summary>Specifies if term positions should be returned.</summary>
		public bool Positions { get { return Q<bool>("positions"); } set { Q("positions", value); } }
		
		///<summary>Specifies if term payloads should be returned.</summary>
		public bool Payloads { get { return Q<bool>("payloads"); } set { Q("payloads", value); } }
		
		///<summary>Specify the node or shard the operation should be performed on (default: random).</summary>
		public string Preference { get { return Q<string>("preference"); } set { Q("preference", value); } }
		
		///<summary>Specific routing value.</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>Parent id of documents.</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Specifies if request is real-time as opposed to near-real-time (default: true).</summary>
		public bool Realtime { get { return Q<bool>("realtime"); } set { Q("realtime", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface ITypeExistsRequest : IRequest<TypeExistsRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for IndicesExistsType <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-types-exists.html</pre></summary>
	public partial class TypeExistsRequest  : RequestBase<TypeExistsRequestParameters>, ITypeExistsRequest
	{
		protected ITypeExistsRequest Self => this;
		Indices ITypeExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ITypeExistsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/{type}</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>
		public TypeExistsRequest(Indices index, Types type) : base(r=>r.Required("index", index).Required("type", type)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public bool Local { get { return Q<bool>("local"); } set { Q("local", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IUpdateIndexSettingsRequest : IRequest<UpdateIndexSettingsRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesPutSettingsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html</pre></summary>
	public partial class UpdateIndexSettingsRequest  : RequestBase<UpdateIndexSettingsRequestParameters>, IUpdateIndexSettingsRequest
	{
		protected IUpdateIndexSettingsRequest Self => this;
		Indices IUpdateIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_settings</summary>
		public UpdateIndexSettingsRequest() : base(){}
		

		/// <summary>/{index}/_settings</summary>
///<param name="index">Optional, accepts null</param>
		public UpdateIndexSettingsRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Specify timeout for connection to master</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Return settings in flat format (default: false)</summary>
		public bool FlatSettings { get { return Q<bool>("flat_settings"); } set { Q("flat_settings", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IUpdateRequest<TDocument, TPartialDocument> : IRequest<UpdateRequestParameters> 
	{
		Id Id { get; }
		IndexName Index { get; }
		TypeName Type { get; }
	 } 
	///<summary>Request parameters for Update <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html</pre></summary>
	public partial class UpdateRequest<TDocument, TPartialDocument>  : RequestBase<UpdateRequestParameters>, IUpdateRequest<TDocument, TPartialDocument>
	{
		protected IUpdateRequest<TDocument, TPartialDocument> Self => this;
		Id IUpdateRequest<TDocument, TPartialDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IUpdateRequest<TDocument, TPartialDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IUpdateRequest<TDocument, TPartialDocument>.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}/_update</summary>
///<param name="index">this parameter is required</param>		
///<param name="type">this parameter is required</param>		
///<param name="id">this parameter is required</param>
		public UpdateRequest(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}/_update</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public UpdateRequest(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>Explicit write consistency setting for the operation</summary>
		public Consistency Consistency { get { return Q<Consistency>("consistency"); } set { Q("consistency", value); } }
		
		///<summary>The script language (default: groovy)</summary>
		public string Lang { get { return Q<string>("lang"); } set { Q("lang", value); } }
		
		///<summary>ID of the parent document. Is is only used for routing and when for the upsert request</summary>
		public string Parent { get { return Q<string>("parent"); } set { Q("parent", value); } }
		
		///<summary>Refresh the index after performing the operation</summary>
		public bool Refresh { get { return Q<bool>("refresh"); } set { Q("refresh", value); } }
		
		///<summary>Specify how many times should the operation be retried when a conflict occurs (default: 0)</summary>
		public long RetryOnConflict { get { return Q<long>("retry_on_conflict"); } set { Q("retry_on_conflict", value); } }
		
		///<summary>Specific routing value</summary>
		public string Routing { get { return Q<string>("routing"); } set { Q("routing", value); } }
		
		///<summary>The URL-encoded script definition (instead of using request body)</summary>
		public string ScriptQueryString { get { return Q<string>("script"); } set { Q("script", value); } }
		
		///<summary>The id of a stored script</summary>
		public string ScriptId { get { return Q<string>("script_id"); } set { Q("script_id", value); } }
		
		///<summary>True if the script referenced in script or script_id should be called to perform inserts - defaults to false</summary>
		public bool ScriptedUpsert { get { return Q<bool>("scripted_upsert"); } set { Q("scripted_upsert", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>Explicit timestamp for the document</summary>
		public string Timestamp { get { return Q<string>("timestamp"); } set { Q("timestamp", value); } }
		
		///<summary>Expiration time for the document</summary>
		public string Ttl { get { return Q<string>("ttl"); } set { Q("ttl", value); } }
		
		///<summary>Explicit version number for concurrency control</summary>
		public long Version { get { return Q<long>("version"); } set { Q("version", value); } }
		
		///<summary>Specific version type</summary>
		public VersionType VersionType { get { return Q<VersionType>("version_type"); } set { Q("version_type", value); } }
		
		///<summary>Specifying as true will cause Elasticsearch to check if there are changes and, if there aren&#226;€™t, turn the update request into a noop.</summary>
		public bool DetectNoop { get { return Q<bool>("detect_noop"); } set { Q("detect_noop", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IUpgradeRequest : IRequest<UpgradeRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesUpgradeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeRequest  : RequestBase<UpgradeRequestParameters>, IUpgradeRequest
	{
		protected IUpgradeRequest Self => this;
		Indices IUpgradeRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_upgrade</summary>
		public UpgradeRequest() : base(){}
		

		/// <summary>/{index}/_upgrade</summary>
///<param name="index">Optional, accepts null</param>
		public UpgradeRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Specify whether the request should block until the all segments are upgraded (default: false)</summary>
		public bool WaitForCompletion { get { return Q<bool>("wait_for_completion"); } set { Q("wait_for_completion", value); } }
		
		///<summary>If true, only ancient (an older Lucene major release) segments will be upgraded</summary>
		public bool OnlyAncientSegments { get { return Q<bool>("only_ancient_segments"); } set { Q("only_ancient_segments", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IUpgradeStatusRequest : IRequest<UpgradeStatusRequestParameters> 
	{
		Indices Index { get; }
	 } 
	///<summary>Request parameters for IndicesGetUpgradeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeStatusRequest  : RequestBase<UpgradeStatusRequestParameters>, IUpgradeStatusRequest
	{
		protected IUpgradeStatusRequest Self => this;
		Indices IUpgradeStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_upgrade</summary>
		public UpgradeStatusRequest() : base(){}
		

		/// <summary>/{index}/_upgrade</summary>
///<param name="index">Optional, accepts null</param>
		public UpgradeStatusRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

			///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public bool Human { get { return Q<bool>("human"); } set { Q("human", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IValidateQueryRequest : IRequest<ValidateQueryRequestParameters> 
	{
		Indices Index { get; }
		Types Type { get; }
	 } 
	///<summary>Request parameters for IndicesValidateQueryForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html</pre></summary>
	public partial class ValidateQueryRequest<T>  : RequestBase<ValidateQueryRequestParameters>, IValidateQueryRequest
	{
		protected IValidateQueryRequest Self => this;
		Indices IValidateQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IValidateQueryRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_validate/query</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public ValidateQueryRequest() : this(typeof(T), typeof(T)) {}
		

		/// <summary>/{index}/_validate/query</summary>
///<param name="index">Optional, accepts null</param>
		public ValidateQueryRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_validate/query</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public ValidateQueryRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Return detailed information about the error</summary>
		public bool Explain { get { return Q<bool>("explain"); } set { Q("explain", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>TODO: ?</summary>
		public string OperationThreading { get { return Q<string>("operation_threading"); } set { Q("operation_threading", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>Provide a more detailed explanation showing the actual Lucene query that will be executed.</summary>
		public bool Rewrite { get { return Q<bool>("rewrite"); } set { Q("rewrite", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	///<summary>Request parameters for IndicesValidateQueryForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html</pre></summary>
	public partial class ValidateQueryRequest  : RequestBase<ValidateQueryRequestParameters>, IValidateQueryRequest
	{
		protected IValidateQueryRequest Self => this;
		Indices IValidateQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IValidateQueryRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_validate/query</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public ValidateQueryRequest() {}
		

		/// <summary>/{index}/_validate/query</summary>
///<param name="index">Optional, accepts null</param>
		public ValidateQueryRequest(Indices index) : base(r=>r.Optional("index", index)){}
		

		/// <summary>/{index}/{type}/_validate/query</summary>
///<param name="index">Optional, accepts null</param>		
///<param name="type">Optional, accepts null</param>
		public ValidateQueryRequest(Indices index, Types type) : base(r=>r.Optional("index", index).Optional("type", type)){}
		

			///<summary>Return detailed information about the error</summary>
		public bool Explain { get { return Q<bool>("explain"); } set { Q("explain", value); } }
		
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public bool IgnoreUnavailable { get { return Q<bool>("ignore_unavailable"); } set { Q("ignore_unavailable", value); } }
		
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public bool AllowNoIndices { get { return Q<bool>("allow_no_indices"); } set { Q("allow_no_indices", value); } }
		
		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ExpandWildcards ExpandWildcards { get { return Q<ExpandWildcards>("expand_wildcards"); } set { Q("expand_wildcards", value); } }
		
		///<summary>TODO: ?</summary>
		public string OperationThreading { get { return Q<string>("operation_threading"); } set { Q("operation_threading", value); } }
		
		///<summary>Query in the Lucene query string syntax</summary>
		public string QueryOnQueryString { get { return Q<string>("q"); } set { Q("q", value); } }
		
		///<summary>The analyzer to use for the query string</summary>
		public string Analyzer { get { return Q<string>("analyzer"); } set { Q("analyzer", value); } }
		
		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public bool AnalyzeWildcard { get { return Q<bool>("analyze_wildcard"); } set { Q("analyze_wildcard", value); } }
		
		///<summary>The default operator for query string query (AND or OR)</summary>
		public DefaultOperator DefaultOperator { get { return Q<DefaultOperator>("default_operator"); } set { Q("default_operator", value); } }
		
		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public string Df { get { return Q<string>("df"); } set { Q("df", value); } }
		
		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public bool Lenient { get { return Q<bool>("lenient"); } set { Q("lenient", value); } }
		
		///<summary>Specify whether query terms should be lowercased</summary>
		public bool LowercaseExpandedTerms { get { return Q<bool>("lowercase_expanded_terms"); } set { Q("lowercase_expanded_terms", value); } }
		
		///<summary>Provide a more detailed explanation showing the actual Lucene query that will be executed.</summary>
		public bool Rewrite { get { return Q<bool>("rewrite"); } set { Q("rewrite", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
	
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface IVerifyRepositoryRequest : IRequest<VerifyRepositoryRequestParameters> 
	{
		Name RepositoryName { get; }
	 } 
	///<summary>Request parameters for SnapshotVerifyRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class VerifyRepositoryRequest  : RequestBase<VerifyRepositoryRequestParameters>, IVerifyRepositoryRequest
	{
		protected IVerifyRepositoryRequest Self => this;
		Name IVerifyRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
			/// <summary>/_snapshot/{repository}/_verify</summary>
///<param name="repository">this parameter is required</param>
		public VerifyRepositoryRequest(Name repository) : base(r=>r.Required("repository", repository)){}
		

			///<summary>Explicit operation timeout for connection to master node</summary>
		public string MasterTimeout { get { return Q<string>("master_timeout"); } set { Q("master_timeout", value); } }
		
		///<summary>Explicit operation timeout</summary>
		public string Timeout { get { return Q<string>("timeout"); } set { Q("timeout", value); } }
		
		///<summary>The URL-encoded request definition</summary>
		public string Source { get { return Q<string>("source"); } set { Q("source", value); } }
		
		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public string FilterPath { get { return Q<string>("filter_path"); } set { Q("filter_path", value); } }
		
		}
}
 