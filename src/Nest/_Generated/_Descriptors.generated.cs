using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;

//This file lays the base for all the descriptors based on the query string parameters in the spec for IElasticClient.
//This file is automatically generated from https://github.com/elasticsearch/elasticsearch-rest-api-spec
//Generated of commit 

namespace Nest
{
	
	///<summary>descriptor for Bulk <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-bulk.html</pre></summary>
	public partial class BulkDescriptor  : RequestDescriptorBase<BulkDescriptor,BulkRequestParameters, IBulkRequest>, IBulkRequest
	{ 
		IndexName IBulkRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IBulkRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_bulk</summary>
		public BulkDescriptor() : base(){}
		

			///<summary>Default index for items which don't provide one</summary>
		public BulkDescriptor Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>Default index for items which don't provide one</summary>
		public BulkDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>Default document type for items which don't provide one</summary>
		public BulkDescriptor Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>Default document type for items which don't provide one</summary>
		public BulkDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Explicit write consistency setting for the operation</summary>
		public BulkDescriptor Consistency(Consistency consistency) => AssignParam(p=>p.Consistency(consistency));

		///<summary>Refresh the index after performing the operation</summary>
		public BulkDescriptor Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>Specific routing value</summary>
		public BulkDescriptor Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Explicit operation timeout</summary>
		public BulkDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Default comma-separated list of fields to return in the response for updates</summary>
		public BulkDescriptor Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>Default comma-separated list of fields to return in the response for updates</summary>
		public BulkDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._Fields(fields));

		///<summary>The URL-encoded request definition</summary>
		public BulkDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public BulkDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatAliases <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-alias.html</pre></summary>
	public partial class CatAliasesDescriptor  : RequestDescriptorBase<CatAliasesDescriptor,CatAliasesRequestParameters, ICatAliasesRequest>, ICatAliasesRequest
	{ 
		Names ICatAliasesRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_cat/aliases</summary>
		public CatAliasesDescriptor() : base(){}
		

			///<summary>A comma-separated list of alias names to return</summary>
		public CatAliasesDescriptor Name(Names name) => Assign(a=>a.RouteValues.Optional("name", name));

	
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAliasesDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAliasesDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatAliasesDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatAliasesDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatAliasesDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatAliasesDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatAliasesDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatAllocation <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-allocation.html</pre></summary>
	public partial class CatAllocationDescriptor  : RequestDescriptorBase<CatAllocationDescriptor,CatAllocationRequestParameters, ICatAllocationRequest>, ICatAllocationRequest
	{ 
		NodeIds ICatAllocationRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_cat/allocation</summary>
		public CatAllocationDescriptor() : base(){}
		

			///<summary>A comma-separated list of node IDs or names to limit the returned information</summary>
		public CatAllocationDescriptor NodeId(NodeIds nodeId) => Assign(a=>a.RouteValues.Optional("node_id", nodeId));

	
		///<summary>The unit in which to display byte values</summary>
		public CatAllocationDescriptor Bytes(Bytes bytes) => AssignParam(p=>p.Bytes(bytes));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatAllocationDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatAllocationDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatAllocationDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatAllocationDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatAllocationDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatAllocationDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatAllocationDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatCount <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html</pre></summary>
	public partial class CatCountDescriptor  : RequestDescriptorBase<CatCountDescriptor,CatCountRequestParameters, ICatCountRequest>, ICatCountRequest
	{ 
		Indices ICatCountRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/count</summary>
		public CatCountDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatCountDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatCountDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatCountDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatCountDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatCountDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatCountDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatCountDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatCountDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatCountDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatCountDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatFielddata <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html</pre></summary>
	public partial class CatFielddataDescriptor  : RequestDescriptorBase<CatFielddataDescriptor,CatFielddataRequestParameters, ICatFielddataRequest>, ICatFielddataRequest
	{ 
		FieldNames ICatFielddataRequest.Fields => Self.RouteValues.Get<FieldNames>("fields");
			/// <summary>/_cat/fielddata</summary>
		public CatFielddataDescriptor() : base(){}
		

			///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields(FieldNames fields) => Assign(a=>a.RouteValues.Optional("fields", fields));

		///<summary>A comma-separated list of fields to return the fielddata size</summary>
		public CatFielddataDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) => Assign(a => a.RouteValues.Optional("fields", (FieldNames)fields));

	
		///<summary>The unit in which to display byte values</summary>
		public CatFielddataDescriptor Bytes(Bytes bytes) => AssignParam(p=>p.Bytes(bytes));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatFielddataDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatFielddataDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatFielddataDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatFielddataDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatFielddataDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatFielddataDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatFielddataDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatHealth <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html</pre></summary>
	public partial class CatHealthDescriptor  : RequestDescriptorBase<CatHealthDescriptor,CatHealthRequestParameters, ICatHealthRequest>, ICatHealthRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatHealthDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatHealthDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatHealthDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatHealthDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Set to false to disable timestamping</summary>
		public CatHealthDescriptor Ts(bool ts = true) => AssignParam(p=>p.Ts(ts));

		///<summary>Verbose mode. Display column headers</summary>
		public CatHealthDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatHealthDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatHealthDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatHelp <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html</pre></summary>
	public partial class CatHelpDescriptor  : RequestDescriptorBase<CatHelpDescriptor,CatHelpRequestParameters, ICatHelpRequest>, ICatHelpRequest
	{ 
			
		///<summary>Return help information</summary>
		public CatHelpDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>The URL-encoded request definition</summary>
		public CatHelpDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatHelpDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));

		//TODO THIS METHOD IS UNMAPPED!
		
	
	}
	
	///<summary>descriptor for CatIndices <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-indices.html</pre></summary>
	public partial class CatIndicesDescriptor  : RequestDescriptorBase<CatIndicesDescriptor,CatIndicesRequestParameters, ICatIndicesRequest>, ICatIndicesRequest
	{ 
		Indices ICatIndicesRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/indices</summary>
		public CatIndicesDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatIndicesDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatIndicesDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatIndicesDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>The unit in which to display byte values</summary>
		public CatIndicesDescriptor Bytes(Bytes bytes) => AssignParam(p=>p.Bytes(bytes));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatIndicesDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatIndicesDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatIndicesDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatIndicesDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Set to true to return stats only for primary shards</summary>
		public CatIndicesDescriptor Pri(bool pri = true) => AssignParam(p=>p.Pri(pri));

		///<summary>Verbose mode. Display column headers</summary>
		public CatIndicesDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatIndicesDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatIndicesDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatMaster <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-master.html</pre></summary>
	public partial class CatMasterDescriptor  : RequestDescriptorBase<CatMasterDescriptor,CatMasterRequestParameters, ICatMasterRequest>, ICatMasterRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatMasterDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatMasterDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatMasterDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatMasterDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatMasterDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatMasterDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatMasterDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatNodeattrs <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodeattrs.html</pre></summary>
	public partial class CatNodeattrsDescriptor  : RequestDescriptorBase<CatNodeattrsDescriptor,CatNodeattrsRequestParameters, ICatNodeattrsRequest>, ICatNodeattrsRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodeattrsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodeattrsDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatNodeattrsDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatNodeattrsDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatNodeattrsDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatNodeattrsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatNodeattrsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));

		//TODO THIS METHOD IS UNMAPPED!
		
	
	}
	
	///<summary>descriptor for CatNodes <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodes.html</pre></summary>
	public partial class CatNodesDescriptor  : RequestDescriptorBase<CatNodesDescriptor,CatNodesRequestParameters, ICatNodesRequest>, ICatNodesRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatNodesDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatNodesDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatNodesDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatNodesDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatNodesDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatNodesDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatNodesDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatPendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-pending-tasks.html</pre></summary>
	public partial class CatPendingTasksDescriptor  : RequestDescriptorBase<CatPendingTasksDescriptor,CatPendingTasksRequestParameters, ICatPendingTasksRequest>, ICatPendingTasksRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPendingTasksDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPendingTasksDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatPendingTasksDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatPendingTasksDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatPendingTasksDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatPendingTasksDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatPendingTasksDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatPlugins <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html</pre></summary>
	public partial class CatPluginsDescriptor  : RequestDescriptorBase<CatPluginsDescriptor,CatPluginsRequestParameters, ICatPluginsRequest>, ICatPluginsRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatPluginsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatPluginsDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatPluginsDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatPluginsDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatPluginsDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatPluginsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatPluginsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatRecovery <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html</pre></summary>
	public partial class CatRecoveryDescriptor  : RequestDescriptorBase<CatRecoveryDescriptor,CatRecoveryRequestParameters, ICatRecoveryRequest>, ICatRecoveryRequest
	{ 
		Indices ICatRecoveryRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/recovery</summary>
		public CatRecoveryDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatRecoveryDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatRecoveryDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatRecoveryDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>The unit in which to display byte values</summary>
		public CatRecoveryDescriptor Bytes(Bytes bytes) => AssignParam(p=>p.Bytes(bytes));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatRecoveryDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatRecoveryDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatRecoveryDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatRecoveryDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatRecoveryDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatRecoveryDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatSegments <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html</pre></summary>
	public partial class CatSegmentsDescriptor  : RequestDescriptorBase<CatSegmentsDescriptor,CatSegmentsRequestParameters, ICatSegmentsRequest>, ICatSegmentsRequest
	{ 
		Indices ICatSegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/segments</summary>
		public CatSegmentsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatSegmentsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatSegmentsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatSegmentsDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Comma-separated list of column names to display</summary>
		public CatSegmentsDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatSegmentsDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatSegmentsDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatSegmentsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatSegmentsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-shards.html</pre></summary>
	public partial class CatShardsDescriptor  : RequestDescriptorBase<CatShardsDescriptor,CatShardsRequestParameters, ICatShardsRequest>, ICatShardsRequest
	{ 
		Indices ICatShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cat/shards</summary>
		public CatShardsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatShardsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatShardsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to limit the returned information</summary>
		public CatShardsDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatShardsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatShardsDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatShardsDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatShardsDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatShardsDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>The URL-encoded request definition</summary>
		public CatShardsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatShardsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CatThreadPool <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html</pre></summary>
	public partial class CatThreadPoolDescriptor  : RequestDescriptorBase<CatThreadPoolDescriptor,CatThreadPoolRequestParameters, ICatThreadPoolRequest>, ICatThreadPoolRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public CatThreadPoolDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public CatThreadPoolDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Comma-separated list of column names to display</summary>
		public CatThreadPoolDescriptor H(params string[] h) => AssignParam(p=>p.H(h));

		///<summary>Return help information</summary>
		public CatThreadPoolDescriptor Help(bool help = true) => AssignParam(p=>p.Help(help));

		///<summary>Verbose mode. Display column headers</summary>
		public CatThreadPoolDescriptor V(bool v = true) => AssignParam(p=>p.V(v));

		///<summary>Enables displaying the complete node ids</summary>
		public CatThreadPoolDescriptor FullId(bool full_id = true) => AssignParam(p=>p.FullId(full_id));

		///<summary>The URL-encoded request definition</summary>
		public CatThreadPoolDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CatThreadPoolDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClearScroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ClearScrollDescriptor  : RequestDescriptorBase<ClearScrollDescriptor,ClearScrollRequestParameters, IClearScrollRequest>, IClearScrollRequest
	{ 
		ScrollIds IClearScrollRequest.ScrollId => Self.RouteValues.Get<ScrollIds>("scroll_id");
			/// <summary>/_search/scroll/{scroll_id}</summary>
		public ClearScrollDescriptor() : base(){}
		

			///<summary>A comma-separated list of scroll IDs to clear</summary>
		public ClearScrollDescriptor ScrollId(ScrollIds scrollId) => Assign(a=>a.RouteValues.Optional("scroll_id", scrollId));

	
		///<summary>The URL-encoded request definition</summary>
		public ClearScrollDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClearScrollDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClusterGetSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterGetSettingsDescriptor  : RequestDescriptorBase<ClusterGetSettingsDescriptor,ClusterGetSettingsRequestParameters, IClusterGetSettingsRequest>, IClusterGetSettingsRequest
	{ 
			
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterGetSettingsDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterGetSettingsDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Explicit operation timeout</summary>
		public ClusterGetSettingsDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public ClusterGetSettingsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClusterGetSettingsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClusterHealth <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html</pre></summary>
	public partial class ClusterHealthDescriptor  : RequestDescriptorBase<ClusterHealthDescriptor,ClusterHealthRequestParameters, IClusterHealthRequest>, IClusterHealthRequest
	{ 
		Indices IClusterHealthRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cluster/health</summary>
		public ClusterHealthDescriptor() : base(){}
		

			///<summary>Limit the information returned to a specific index</summary>
		public ClusterHealthDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>Limit the information returned to a specific index</summary>
		public ClusterHealthDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>Limit the information returned to a specific index</summary>
		public ClusterHealthDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Specify the level of detail for returned information</summary>
		public ClusterHealthDescriptor Level(Level level) => AssignParam(p=>p.Level(level));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterHealthDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterHealthDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Explicit operation timeout</summary>
		public ClusterHealthDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Wait until the specified number of shards is active</summary>
		public ClusterHealthDescriptor WaitForActiveShards(long wait_for_active_shards) => AssignParam(p=>p.WaitForActiveShards(wait_for_active_shards));

		///<summary>Wait until the specified number of nodes is available</summary>
		public ClusterHealthDescriptor WaitForNodes(string wait_for_nodes) => AssignParam(p=>p.WaitForNodes(wait_for_nodes));

		///<summary>Wait until the specified number of relocating shards is finished</summary>
		public ClusterHealthDescriptor WaitForRelocatingShards(long wait_for_relocating_shards) => AssignParam(p=>p.WaitForRelocatingShards(wait_for_relocating_shards));

		///<summary>Wait until cluster is in a specific state</summary>
		public ClusterHealthDescriptor WaitForStatus(WaitForStatus wait_for_status) => AssignParam(p=>p.WaitForStatus(wait_for_status));

		///<summary>The URL-encoded request definition</summary>
		public ClusterHealthDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClusterHealthDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClusterPendingTasks <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-pending.html</pre></summary>
	public partial class ClusterPendingTasksDescriptor  : RequestDescriptorBase<ClusterPendingTasksDescriptor,ClusterPendingTasksRequestParameters, IClusterPendingTasksRequest>, IClusterPendingTasksRequest
	{ 
			
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterPendingTasksDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Specify timeout for connection to master</summary>
		public ClusterPendingTasksDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public ClusterPendingTasksDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClusterPendingTasksDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClusterPutSettings <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html</pre></summary>
	public partial class ClusterPutSettingsDescriptor  : RequestDescriptorBase<ClusterPutSettingsDescriptor,ClusterPutSettingsRequestParameters, IClusterPutSettingsRequest>, IClusterPutSettingsRequest
	{ 
			
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterPutSettingsDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterPutSettingsDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Explicit operation timeout</summary>
		public ClusterPutSettingsDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public ClusterPutSettingsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClusterPutSettingsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClusterReroute <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-reroute.html</pre></summary>
	public partial class ClusterRerouteDescriptor  : RequestDescriptorBase<ClusterRerouteDescriptor,ClusterRerouteRequestParameters, IClusterRerouteRequest>, IClusterRerouteRequest
	{ 
			
		///<summary>Simulate the operation only and return the resulting state</summary>
		public ClusterRerouteDescriptor DryRun(bool dry_run = true) => AssignParam(p=>p.DryRun(dry_run));

		///<summary>Return an explanation of why the commands can or cannot be executed</summary>
		public ClusterRerouteDescriptor Explain(bool explain = true) => AssignParam(p=>p.Explain(explain));

		///<summary>Limit the information returned to the specified metrics. Defaults to all but metadata</summary>
		public ClusterRerouteDescriptor Metric(params string[] metric) => AssignParam(p=>p.Metric(metric));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public ClusterRerouteDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Explicit operation timeout</summary>
		public ClusterRerouteDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public ClusterRerouteDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClusterRerouteDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClusterState <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-state.html</pre></summary>
	public partial class ClusterStateDescriptor  : RequestDescriptorBase<ClusterStateDescriptor,ClusterStateRequestParameters, IClusterStateRequest>, IClusterStateRequest
	{ 
		Indices IClusterStateRequest.Index => Self.RouteValues.Get<Indices>("index");
		Metrics IClusterStateRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
			/// <summary>/_cluster/state</summary>
		public ClusterStateDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public ClusterStateDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public ClusterStateDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public ClusterStateDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>Limit the information returned to the specified metrics</summary>
		public ClusterStateDescriptor Metric(ClusterStateMetric metric) => Assign(a=>a.RouteValues.Optional("metric", (Metrics)metric));

	
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public ClusterStateDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Specify timeout for connection to master</summary>
		public ClusterStateDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStateDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClusterStateDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClusterStateDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClusterStateDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public ClusterStateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClusterStateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for ClusterStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-stats.html</pre></summary>
	public partial class ClusterStatsDescriptor  : RequestDescriptorBase<ClusterStatsDescriptor,ClusterStatsRequestParameters, IClusterStatsRequest>, IClusterStatsRequest
	{ 
		NodeIds IClusterStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_cluster/stats</summary>
		public ClusterStatsDescriptor() : base(){}
		

			///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public ClusterStatsDescriptor NodeId(NodeIds nodeId) => Assign(a=>a.RouteValues.Optional("node_id", nodeId));

	
		///<summary>Return settings in flat format (default: false)</summary>
		public ClusterStatsDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public ClusterStatsDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>Explicit operation timeout</summary>
		public ClusterStatsDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public ClusterStatsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClusterStatsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Count <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html</pre></summary>
	public partial class CountDescriptor<T>  : RequestDescriptorBase<CountDescriptor<T>,CountRequestParameters, ICountRequest>, ICountRequest
	{ 
		Indices ICountRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ICountRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_count</summary>
		public CountDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		

			///<summary>A comma-separated list of indices to restrict the results</summary>
		public CountDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of indices to restrict the results</summary>
		public CountDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of indices to restrict the results</summary>
		public CountDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of types to restrict the results</summary>
		public CountDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of types to restrict the results</summary>
		public CountDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of types to restrict the results</summary>
		public CountDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CountDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CountDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CountDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public CountDescriptor<T> MinScore(double min_score) => AssignParam(p=>p.MinScore(min_score));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public CountDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specific routing value</summary>
		public CountDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Query in the Lucene query string syntax</summary>
		public CountDescriptor<T> QueryOnQueryString(string query_on_query_string) => AssignParam(p=>p.QueryOnQueryString(query_on_query_string));

		///<summary>The analyzer to use for the query string</summary>
		public CountDescriptor<T> Analyzer(string analyzer) => AssignParam(p=>p.Analyzer(analyzer));

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public CountDescriptor<T> AnalyzeWildcard(bool analyze_wildcard = true) => AssignParam(p=>p.AnalyzeWildcard(analyze_wildcard));

		///<summary>The default operator for query string query (AND or OR)</summary>
		public CountDescriptor<T> DefaultOperator(DefaultOperator default_operator) => AssignParam(p=>p.DefaultOperator(default_operator));

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public CountDescriptor<T> Df(string df) => AssignParam(p=>p.Df(df));

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public CountDescriptor<T> Lenient(bool lenient = true) => AssignParam(p=>p.Lenient(lenient));

		///<summary>Specify whether query terms should be lowercased</summary>
		public CountDescriptor<T> LowercaseExpandedTerms(bool lowercase_expanded_terms = true) => AssignParam(p=>p.LowercaseExpandedTerms(lowercase_expanded_terms));

		///<summary>The URL-encoded request definition</summary>
		public CountDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CountDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for CountPercolate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html</pre></summary>
	public partial class PercolateCountDescriptor<TDocument>  : RequestDescriptorBase<PercolateCountDescriptor<TDocument>,PercolateCountRequestParameters, IPercolateCountRequest<TDocument>>, IPercolateCountRequest<TDocument>
	{ 
		IndexName IPercolateCountRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IPercolateCountRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
		Id IPercolateCountRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/{index}/{type}/_percolate/count</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>
		public PercolateCountDescriptor(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}/_percolate/count</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public PercolateCountDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>The index of the document being count percolated.</summary>
		public PercolateCountDescriptor<TDocument> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The index of the document being count percolated.</summary>
		public PercolateCountDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document being count percolated.</summary>
		public PercolateCountDescriptor<TDocument> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document being count percolated.</summary>
		public PercolateCountDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

		///<summary>Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</summary>
		public PercolateCountDescriptor<TDocument> Id(Id id) => Assign(a=>a.RouteValues.Optional("id", id));

	
		///<summary>A comma-separated list of specific routing values</summary>
		public PercolateCountDescriptor<TDocument> Routing(params string[] routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public PercolateCountDescriptor<TDocument> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PercolateCountDescriptor<TDocument> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PercolateCountDescriptor<TDocument> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PercolateCountDescriptor<TDocument> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The index to count percolate the document into. Defaults to index.</summary>
		public PercolateCountDescriptor<TDocument> PercolateIndex(string percolate_index) => AssignParam(p=>p.PercolateIndex(percolate_index));

		///<summary>The type to count percolate document into. Defaults to type.</summary>
		public PercolateCountDescriptor<TDocument> PercolateType(string percolate_type) => AssignParam(p=>p.PercolateType(percolate_type));

		///<summary>Explicit version number for concurrency control</summary>
		public PercolateCountDescriptor<TDocument> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public PercolateCountDescriptor<TDocument> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public PercolateCountDescriptor<TDocument> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PercolateCountDescriptor<TDocument> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Delete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html</pre></summary>
	public partial class DeleteDescriptor<T>  : RequestDescriptorBase<DeleteDescriptor<T>,DeleteRequestParameters, IDeleteRequest>, IDeleteRequest
	{ 
		Id IDeleteRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDeleteRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDeleteRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public DeleteDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public DeleteDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>The name of the index</summary>
		public DeleteDescriptor<T> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public DeleteDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document</summary>
		public DeleteDescriptor<T> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document</summary>
		public DeleteDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Specific write consistency setting for the operation</summary>
		public DeleteDescriptor<T> Consistency(Consistency consistency) => AssignParam(p=>p.Consistency(consistency));

		///<summary>ID of parent document</summary>
		public DeleteDescriptor<T> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Refresh the index after performing the operation</summary>
		public DeleteDescriptor<T> Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>Specific routing value</summary>
		public DeleteDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Explicit operation timeout</summary>
		public DeleteDescriptor<T> Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Explicit version number for concurrency control</summary>
		public DeleteDescriptor<T> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public DeleteDescriptor<T> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public DeleteDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for DeleteByQuery <pre>https://www.elastic.co/guide/en/elasticsearch/plugins/2.0/plugins-delete-by-query.html</pre></summary>
	public partial class DeleteByQueryDescriptor<T>  : RequestDescriptorBase<DeleteByQueryDescriptor<T>,DeleteByQueryRequestParameters, IDeleteByQueryRequest>, IDeleteByQueryRequest
	{ 
		Indices IDeleteByQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IDeleteByQueryRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/_query</summary>
///<param name="index"> this parameter is required</param>
		public DeleteByQueryDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</summary>
		public DeleteByQueryDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</summary>
		public DeleteByQueryDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices</summary>
		public DeleteByQueryDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of types to restrict the operation</summary>
		public DeleteByQueryDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of types to restrict the operation</summary>
		public DeleteByQueryDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of types to restrict the operation</summary>
		public DeleteByQueryDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>The analyzer to use for the query string</summary>
		public DeleteByQueryDescriptor<T> Analyzer(string analyzer) => AssignParam(p=>p.Analyzer(analyzer));

		///<summary>The default operator for query string query (AND or OR)</summary>
		public DeleteByQueryDescriptor<T> DefaultOperator(DefaultOperator default_operator) => AssignParam(p=>p.DefaultOperator(default_operator));

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public DeleteByQueryDescriptor<T> Df(string df) => AssignParam(p=>p.Df(df));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public DeleteByQueryDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public DeleteByQueryDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public DeleteByQueryDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Query in the Lucene query string syntax</summary>
		public DeleteByQueryDescriptor<T> QueryOnQueryString(string query_on_query_string) => AssignParam(p=>p.QueryOnQueryString(query_on_query_string));

		///<summary>Specific routing value</summary>
		public DeleteByQueryDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>The URL-encoded query definition (instead of using the request body)</summary>
		public DeleteByQueryDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Explicit operation timeout</summary>
		public DeleteByQueryDescriptor<T> Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteByQueryDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for DeleteScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class DeleteScriptDescriptor  : RequestDescriptorBase<DeleteScriptDescriptor,DeleteScriptRequestParameters, IDeleteScriptRequest>, IDeleteScriptRequest
	{ 
		Id IDeleteScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IDeleteScriptRequest.Lang => Self.RouteValues.Get<Name>("lang");
			/// <summary>/_scripts/{lang}/{id}</summary>
///<param name="lang"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public DeleteScriptDescriptor(Name lang, Id id) : base(r=>r.Required("lang", lang).Required("id", id)){}
		

		
		///<summary>Explicit version number for concurrency control</summary>
		public DeleteScriptDescriptor Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public DeleteScriptDescriptor VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public DeleteScriptDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteScriptDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for DeleteTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class DeleteSearchTemplateDescriptor  : RequestDescriptorBase<DeleteSearchTemplateDescriptor,DeleteSearchTemplateRequestParameters, IDeleteSearchTemplateRequest>, IDeleteSearchTemplateRequest
	{ 
		Id IDeleteSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_search/template/{id}</summary>
///<param name="id"> this parameter is required</param>
		public DeleteSearchTemplateDescriptor(Id id) : base(r=>r.Required("id", id)){}
		

		
		///<summary>Explicit version number for concurrency control</summary>
		public DeleteSearchTemplateDescriptor Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public DeleteSearchTemplateDescriptor VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public DeleteSearchTemplateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteSearchTemplateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Exists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class DocumentExistsDescriptor<T>  : RequestDescriptorBase<DocumentExistsDescriptor<T>,DocumentExistsRequestParameters, IDocumentExistsRequest>, IDocumentExistsRequest
	{ 
		Id IDocumentExistsRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IDocumentExistsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IDocumentExistsRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public DocumentExistsDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public DocumentExistsDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>The name of the index</summary>
		public DocumentExistsDescriptor<T> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public DocumentExistsDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document (use `_all` to fetch the first document matching the ID across all types)</summary>
		public DocumentExistsDescriptor<T> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document (use `_all` to fetch the first document matching the ID across all types)</summary>
		public DocumentExistsDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>The ID of the parent document</summary>
		public DocumentExistsDescriptor<T> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public DocumentExistsDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public DocumentExistsDescriptor<T> Realtime(bool realtime = true) => AssignParam(p=>p.Realtime(realtime));

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public DocumentExistsDescriptor<T> Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>Specific routing value</summary>
		public DocumentExistsDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>The URL-encoded request definition</summary>
		public DocumentExistsDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DocumentExistsDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Explain <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html</pre></summary>
	public partial class ExplainDescriptor<TDocument>  : RequestDescriptorBase<ExplainDescriptor<TDocument>,ExplainRequestParameters, IExplainRequest<TDocument>>, IExplainRequest<TDocument>
	{ 
		Id IExplainRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IExplainRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IExplainRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}/_explain</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public ExplainDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}/_explain</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public ExplainDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>The name of the index</summary>
		public ExplainDescriptor<TDocument> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public ExplainDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document</summary>
		public ExplainDescriptor<TDocument> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document</summary>
		public ExplainDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)</summary>
		public ExplainDescriptor<TDocument> AnalyzeWildcard(bool analyze_wildcard = true) => AssignParam(p=>p.AnalyzeWildcard(analyze_wildcard));

		///<summary>The analyzer for the query string query</summary>
		public ExplainDescriptor<TDocument> Analyzer(string analyzer) => AssignParam(p=>p.Analyzer(analyzer));

		///<summary>The default operator for query string query (AND or OR)</summary>
		public ExplainDescriptor<TDocument> DefaultOperator(DefaultOperator default_operator) => AssignParam(p=>p.DefaultOperator(default_operator));

		///<summary>The default field for query string query (default: _all)</summary>
		public ExplainDescriptor<TDocument> Df(string df) => AssignParam(p=>p.Df(df));

		///<summary>A comma-separated list of fields to return in the response</summary>
		public ExplainDescriptor<TDocument> Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public ExplainDescriptor<TDocument> Fields(params Expression<Func<TDocument, object>>[] fields)  =>
			AssignParam(p=>p._Fields(fields));

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ExplainDescriptor<TDocument> Lenient(bool lenient = true) => AssignParam(p=>p.Lenient(lenient));

		///<summary>Specify whether query terms should be lowercased</summary>
		public ExplainDescriptor<TDocument> LowercaseExpandedTerms(bool lowercase_expanded_terms = true) => AssignParam(p=>p.LowercaseExpandedTerms(lowercase_expanded_terms));

		///<summary>The ID of the parent document</summary>
		public ExplainDescriptor<TDocument> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public ExplainDescriptor<TDocument> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Query in the Lucene query string syntax</summary>
		public ExplainDescriptor<TDocument> QueryOnQueryString(string query_on_query_string) => AssignParam(p=>p.QueryOnQueryString(query_on_query_string));

		///<summary>Specific routing value</summary>
		public ExplainDescriptor<TDocument> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public ExplainDescriptor<TDocument> SourceEnabled(params string[] source_enabled) => AssignParam(p=>p.SourceEnabled(source_enabled));

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor<TDocument> SourceExclude(params string[] source_exclude) => AssignParam(p=>p.SourceExclude(source_exclude));
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public ExplainDescriptor<TDocument> SourceExclude(params Expression<Func<TDocument, object>>[] fields)  =>
			AssignParam(p=>p._SourceExclude(fields));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor<TDocument> SourceInclude(params string[] source_include) => AssignParam(p=>p.SourceInclude(source_include));
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public ExplainDescriptor<TDocument> SourceInclude(params Expression<Func<TDocument, object>>[] fields)  =>
			AssignParam(p=>p._SourceInclude(fields));

		///<summary>The URL-encoded request definition</summary>
		public ExplainDescriptor<TDocument> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ExplainDescriptor<TDocument> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for FieldStats <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html</pre></summary>
	public partial class FieldStatsDescriptor  : RequestDescriptorBase<FieldStatsDescriptor,FieldStatsRequestParameters, IFieldStatsRequest>, IFieldStatsRequest
	{ 
		Indices IFieldStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_field_stats</summary>
		public FieldStatsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public FieldStatsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public FieldStatsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public FieldStatsDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>A comma-separated list of fields for to get field statistics for (min value, max value, and more)</summary>
		public FieldStatsDescriptor Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields for to get field statistics for (min value, max value, and more)</summary>
		public FieldStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._Fields(fields));

		///<summary>Defines if field stats should be returned on a per index level or on a cluster wide level</summary>
		public FieldStatsDescriptor Level(Level level) => AssignParam(p=>p.Level(level));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FieldStatsDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FieldStatsDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FieldStatsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public FieldStatsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public FieldStatsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Get <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class GetDescriptor<T>  : RequestDescriptorBase<GetDescriptor<T>,GetRequestParameters, IGetRequest>, IGetRequest
	{ 
		Id IGetRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName IGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IGetRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public GetDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public GetDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>The name of the index</summary>
		public GetDescriptor<T> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public GetDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document (use `_all` to fetch the first document matching the ID across all types)</summary>
		public GetDescriptor<T> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document (use `_all` to fetch the first document matching the ID across all types)</summary>
		public GetDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>A comma-separated list of fields to return in the response</summary>
		public GetDescriptor<T> Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public GetDescriptor<T> Fields(params Expression<Func<T, object>>[] fields)  =>
			AssignParam(p=>p._Fields(fields));

		///<summary>The ID of the parent document</summary>
		public GetDescriptor<T> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public GetDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public GetDescriptor<T> Realtime(bool realtime = true) => AssignParam(p=>p.Realtime(realtime));

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public GetDescriptor<T> Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>Specific routing value</summary>
		public GetDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public GetDescriptor<T> SourceEnabled(params string[] source_enabled) => AssignParam(p=>p.SourceEnabled(source_enabled));

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> SourceExclude(params string[] source_exclude) => AssignParam(p=>p.SourceExclude(source_exclude));
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public GetDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  =>
			AssignParam(p=>p._SourceExclude(fields));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> SourceInclude(params string[] source_include) => AssignParam(p=>p.SourceInclude(source_include));
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public GetDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  =>
			AssignParam(p=>p._SourceInclude(fields));

		///<summary>Explicit version number for concurrency control</summary>
		public GetDescriptor<T> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public GetDescriptor<T> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public GetDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for GetScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class GetScriptDescriptor  : RequestDescriptorBase<GetScriptDescriptor,GetScriptRequestParameters, IGetScriptRequest>, IGetScriptRequest
	{ 
		Id IGetScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IGetScriptRequest.Lang => Self.RouteValues.Get<Name>("lang");
			/// <summary>/_scripts/{lang}/{id}</summary>
///<param name="lang"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public GetScriptDescriptor(Name lang, Id id) : base(r=>r.Required("lang", lang).Required("id", id)){}
		

		
		///<summary>Explicit version number for concurrency control</summary>
		public GetScriptDescriptor Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public GetScriptDescriptor VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public GetScriptDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetScriptDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for GetSource <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html</pre></summary>
	public partial class SourceDescriptor<T>  : RequestDescriptorBase<SourceDescriptor<T>,SourceRequestParameters, ISourceRequest>, ISourceRequest
	{ 
		Id ISourceRequest.Id => Self.RouteValues.Get<Id>("id");
		IndexName ISourceRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ISourceRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}/_source</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public SourceDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}/_source</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public SourceDescriptor(DocumentPath<T> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(T document);

			///<summary>The name of the index</summary>
		public SourceDescriptor<T> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public SourceDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document; use `_all` to fetch the first document matching the ID across all types</summary>
		public SourceDescriptor<T> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document; use `_all` to fetch the first document matching the ID across all types</summary>
		public SourceDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>The ID of the parent document</summary>
		public SourceDescriptor<T> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SourceDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public SourceDescriptor<T> Realtime(bool realtime = true) => AssignParam(p=>p.Realtime(realtime));

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public SourceDescriptor<T> Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>Specific routing value</summary>
		public SourceDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public SourceDescriptor<T> SourceEnabled(params string[] source_enabled) => AssignParam(p=>p.SourceEnabled(source_enabled));

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> SourceExclude(params string[] source_exclude) => AssignParam(p=>p.SourceExclude(source_exclude));
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public SourceDescriptor<T> SourceExclude(params Expression<Func<T, object>>[] fields)  =>
			AssignParam(p=>p._SourceExclude(fields));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> SourceInclude(params string[] source_include) => AssignParam(p=>p.SourceInclude(source_include));
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public SourceDescriptor<T> SourceInclude(params Expression<Func<T, object>>[] fields)  =>
			AssignParam(p=>p._SourceInclude(fields));

		///<summary>Explicit version number for concurrency control</summary>
		public SourceDescriptor<T> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public SourceDescriptor<T> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public SourceDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SourceDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for GetTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class GetSearchTemplateDescriptor  : RequestDescriptorBase<GetSearchTemplateDescriptor,GetSearchTemplateRequestParameters, IGetSearchTemplateRequest>, IGetSearchTemplateRequest
	{ 
		Id IGetSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_search/template/{id}</summary>
///<param name="id"> this parameter is required</param>
		public GetSearchTemplateDescriptor(Id id) : base(r=>r.Required("id", id)){}
		

		
		///<summary>Explicit version number for concurrency control</summary>
		public GetSearchTemplateDescriptor Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public GetSearchTemplateDescriptor VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public GetSearchTemplateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetSearchTemplateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Index <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html</pre></summary>
	public partial class IndexDescriptor<TDocument>  : RequestDescriptorBase<IndexDescriptor<TDocument>,IndexRequestParameters, IIndexRequest<TDocument>>, IIndexRequest<TDocument>
	{ 
		Id IIndexRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IIndexRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IIndexRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>
		public IndexDescriptor(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public IndexDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>Document ID</summary>
		public IndexDescriptor<TDocument> Id(Id id) => Assign(a=>a.RouteValues.Optional("id", id));

		///<summary>The name of the index</summary>
		public IndexDescriptor<TDocument> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public IndexDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document</summary>
		public IndexDescriptor<TDocument> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document</summary>
		public IndexDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Explicit write consistency setting for the operation</summary>
		public IndexDescriptor<TDocument> Consistency(Consistency consistency) => AssignParam(p=>p.Consistency(consistency));

		///<summary>Explicit operation type</summary>
		public IndexDescriptor<TDocument> OpType(OpType op_type) => AssignParam(p=>p.OpType(op_type));

		///<summary>ID of the parent document</summary>
		public IndexDescriptor<TDocument> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Refresh the index after performing the operation</summary>
		public IndexDescriptor<TDocument> Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>Specific routing value</summary>
		public IndexDescriptor<TDocument> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Explicit operation timeout</summary>
		public IndexDescriptor<TDocument> Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Explicit timestamp for the document</summary>
		public IndexDescriptor<TDocument> Timestamp(string timestamp) => AssignParam(p=>p.Timestamp(timestamp));

		///<summary>Expiration time for the document</summary>
		public IndexDescriptor<TDocument> Ttl(string ttl) => AssignParam(p=>p.Ttl(ttl));

		///<summary>Explicit version number for concurrency control</summary>
		public IndexDescriptor<TDocument> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public IndexDescriptor<TDocument> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public IndexDescriptor<TDocument> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public IndexDescriptor<TDocument> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesAnalyzeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html</pre></summary>
	public partial class AnalyzeDescriptor  : RequestDescriptorBase<AnalyzeDescriptor,AnalyzeRequestParameters, IAnalyzeRequest>, IAnalyzeRequest
	{ 
		IndexName IAnalyzeRequest.Index => Self.RouteValues.Get<IndexName>("index");
			/// <summary>/_analyze</summary>
		public AnalyzeDescriptor() : base(){}
		

			///<summary>The name of the index to scope the operation</summary>
		public AnalyzeDescriptor Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index to scope the operation</summary>
		public AnalyzeDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

	
		///<summary>The name of the analyzer to use</summary>
		public AnalyzeDescriptor Analyzer(string analyzer) => AssignParam(p=>p.Analyzer(analyzer));

		///<summary>A comma-separated list of character filters to use for the analysis</summary>
		public AnalyzeDescriptor CharFilters(params string[] char_filters) => AssignParam(p=>p.CharFilters(char_filters));

		///<summary>Use the analyzer configured for this field (instead of passing the analyzer name)</summary>
		public AnalyzeDescriptor Field(string field) => AssignParam(p=>p.Field(field));

		///<summary>Use the analyzer configured for this field (instead of passing the analyzer name)</summary>
		public AnalyzeDescriptor Field<T>(Expression<Func<T, object>> field) where T : class =>
			AssignParam(p=>p._Field(field));

		///<summary>A comma-separated list of filters to use for the analysis</summary>
		public AnalyzeDescriptor Filters(params string[] filters) => AssignParam(p=>p.Filters(filters));

		///<summary>With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)</summary>
		public AnalyzeDescriptor PreferLocal(bool prefer_local = true) => AssignParam(p=>p.PreferLocal(prefer_local));

		///<summary>The text on which the analysis should be performed (when request body is not used)</summary>
		public AnalyzeDescriptor Text(params string[] text) => AssignParam(p=>p.Text(text));

		///<summary>The name of the tokenizer to use for the analysis</summary>
		public AnalyzeDescriptor Tokenizer(string tokenizer) => AssignParam(p=>p.Tokenizer(tokenizer));

		///<summary>Format of the output</summary>
		public AnalyzeDescriptor Format(Format format) => AssignParam(p=>p.Format(format));

		///<summary>The URL-encoded request definition</summary>
		public AnalyzeDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public AnalyzeDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesClearCacheForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-clearcache.html</pre></summary>
	public partial class ClearCacheDescriptor  : RequestDescriptorBase<ClearCacheDescriptor,ClearCacheRequestParameters, IClearCacheRequest>, IClearCacheRequest
	{ 
		Indices IClearCacheRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_cache/clear</summary>
		public ClearCacheDescriptor() : base(){}
		

			///<summary>A comma-separated list of index name to limit the operation</summary>
		public ClearCacheDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index name to limit the operation</summary>
		public ClearCacheDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index name to limit the operation</summary>
		public ClearCacheDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Clear field data</summary>
		public ClearCacheDescriptor FieldData(bool field_data = true) => AssignParam(p=>p.FieldData(field_data));

		///<summary>A comma-separated list of fields to clear when using the `field_data` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields to clear when using the `field_data` parameter (default: all)</summary>
		public ClearCacheDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._Fields(fields));

		///<summary>Clear query caches</summary>
		public ClearCacheDescriptor Query(bool query = true) => AssignParam(p=>p.Query(query));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ClearCacheDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ClearCacheDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ClearCacheDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Clear the recycler cache</summary>
		public ClearCacheDescriptor Recycler(bool recycler = true) => AssignParam(p=>p.Recycler(recycler));

		///<summary>Clear request cache</summary>
		public ClearCacheDescriptor Request(bool request = true) => AssignParam(p=>p.Request(request));

		///<summary>The URL-encoded request definition</summary>
		public ClearCacheDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ClearCacheDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesClose <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class CloseIndexDescriptor  : RequestDescriptorBase<CloseIndexDescriptor,CloseIndexRequestParameters, ICloseIndexRequest>, ICloseIndexRequest
	{ 
		Indices ICloseIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}/_close</summary>
///<param name="index"> this parameter is required</param>
		public CloseIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>A comma separated list of indices to close</summary>
		public CloseIndexDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma separated list of indices to close</summary>
		public CloseIndexDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma separated list of indices to close</summary>
		public CloseIndexDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Explicit operation timeout</summary>
		public CloseIndexDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public CloseIndexDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public CloseIndexDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public CloseIndexDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public CloseIndexDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public CloseIndexDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CloseIndexDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesCreate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html</pre></summary>
	public partial class CreateIndexDescriptor  : RequestDescriptorBase<CreateIndexDescriptor,CreateIndexRequestParameters, ICreateIndexRequest>, ICreateIndexRequest
	{ 
		IndexName ICreateIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
			/// <summary>/{index}</summary>
///<param name="index"> this parameter is required</param>
		public CreateIndexDescriptor(IndexName index) : base(r=>r.Required("index", index)){}
		

			///<summary>The name of the index</summary>
		public CreateIndexDescriptor Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public CreateIndexDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

	
		///<summary>Explicit operation timeout</summary>
		public CreateIndexDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public CreateIndexDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Whether to update the mapping for all fields with the same name across all types or not</summary>
		public CreateIndexDescriptor UpdateAllTypes(bool update_all_types = true) => AssignParam(p=>p.UpdateAllTypes(update_all_types));

		///<summary>The URL-encoded request definition</summary>
		public CreateIndexDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CreateIndexDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesDelete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html</pre></summary>
	public partial class DeleteIndexDescriptor  : RequestDescriptorBase<DeleteIndexDescriptor,DeleteIndexRequestParameters, IDeleteIndexRequest>, IDeleteIndexRequest
	{ 
		Indices IDeleteIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}</summary>
///<param name="index"> this parameter is required</param>
		public DeleteIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</summary>
		public DeleteIndexDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</summary>
		public DeleteIndexDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices</summary>
		public DeleteIndexDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Explicit operation timeout</summary>
		public DeleteIndexDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public DeleteIndexDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteIndexDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesDeleteAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class DeleteAliasDescriptor  : RequestDescriptorBase<DeleteAliasDescriptor,DeleteAliasRequestParameters, IDeleteAliasRequest>, IDeleteAliasRequest
	{ 
		Indices IDeleteAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IDeleteAliasRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/{index}/_alias/{name}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="name"> this parameter is required</param>
		public DeleteAliasDescriptor(Indices index, Names name) : base(r=>r.Required("index", index).Required("name", name)){}
		

			///<summary>A comma-separated list of index names (supports wildcards); use `_all` for all indices</summary>
		public DeleteAliasDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names (supports wildcards); use `_all` for all indices</summary>
		public DeleteAliasDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names (supports wildcards); use `_all` for all indices</summary>
		public DeleteAliasDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Explicit timestamp for the document</summary>
		public DeleteAliasDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public DeleteAliasDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public DeleteAliasDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteAliasDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesDeleteTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class DeleteIndexTemplateDescriptor  : RequestDescriptorBase<DeleteIndexTemplateDescriptor,DeleteIndexTemplateRequestParameters, IDeleteIndexTemplateRequest>, IDeleteIndexTemplateRequest
	{ 
		Name IDeleteIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/_template/{name}</summary>
///<param name="name"> this parameter is required</param>
		public DeleteIndexTemplateDescriptor(Name name) : base(r=>r.Required("name", name)){}
		

		
		///<summary>Explicit operation timeout</summary>
		public DeleteIndexTemplateDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public DeleteIndexTemplateDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public DeleteIndexTemplateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteIndexTemplateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesDeleteWarmer <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html</pre></summary>
	public partial class DeleteWarmerDescriptor  : RequestDescriptorBase<DeleteWarmerDescriptor,DeleteWarmerRequestParameters, IDeleteWarmerRequest>, IDeleteWarmerRequest
	{ 
		Indices IDeleteWarmerRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IDeleteWarmerRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/{index}/_warmer/{name}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="name"> this parameter is required</param>
		public DeleteWarmerDescriptor(Indices index, Names name) : base(r=>r.Required("index", index).Required("name", name)){}
		

			///<summary>A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public DeleteWarmerDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public DeleteWarmerDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public DeleteWarmerDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Specify timeout for connection to master</summary>
		public DeleteWarmerDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public DeleteWarmerDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteWarmerDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html</pre></summary>
	public partial class IndexExistsDescriptor  : RequestDescriptorBase<IndexExistsDescriptor,IndexExistsRequestParameters, IIndexExistsRequest>, IIndexExistsRequest
	{ 
		Indices IIndexExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}</summary>
///<param name="index"> this parameter is required</param>
		public IndexExistsDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>A comma-separated list of indices to check</summary>
		public IndexExistsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of indices to check</summary>
		public IndexExistsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of indices to check</summary>
		public IndexExistsDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndexExistsDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndexExistsDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndexExistsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexExistsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public IndexExistsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public IndexExistsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesExistsAliasForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class AliasExistsDescriptor  : RequestDescriptorBase<AliasExistsDescriptor,AliasExistsRequestParameters, IAliasExistsRequest>, IAliasExistsRequest
	{ 
		Indices IAliasExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IAliasExistsRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_alias/{name}</summary>
		public AliasExistsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to filter aliases</summary>
		public AliasExistsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public AliasExistsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public AliasExistsDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of alias names to return</summary>
		public AliasExistsDescriptor Name(Names name) => Assign(a=>a.RouteValues.Optional("name", name));

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public AliasExistsDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public AliasExistsDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public AliasExistsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public AliasExistsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public AliasExistsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public AliasExistsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesExistsTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class IndexTemplateExistsDescriptor  : RequestDescriptorBase<IndexTemplateExistsDescriptor,IndexTemplateExistsRequestParameters, IIndexTemplateExistsRequest>, IIndexTemplateExistsRequest
	{ 
		Name IIndexTemplateExistsRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/_template/{name}</summary>
///<param name="name"> this parameter is required</param>
		public IndexTemplateExistsDescriptor(Name name) : base(r=>r.Required("name", name)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public IndexTemplateExistsDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public IndexTemplateExistsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public IndexTemplateExistsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public IndexTemplateExistsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesExistsType <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-types-exists.html</pre></summary>
	public partial class TypeExistsDescriptor  : RequestDescriptorBase<TypeExistsDescriptor,TypeExistsRequestParameters, ITypeExistsRequest>, ITypeExistsRequest
	{ 
		Indices ITypeExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ITypeExistsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/{type}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>
		public TypeExistsDescriptor(Indices index, Types type) : base(r=>r.Required("index", index).Required("type", type)){}
		

			///<summary>A comma-separated list of index names; use `_all` to check the types across all indices</summary>
		public TypeExistsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` to check the types across all indices</summary>
		public TypeExistsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` to check the types across all indices</summary>
		public TypeExistsDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to check</summary>
		public TypeExistsDescriptor Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to check</summary>
		public TypeExistsDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to check</summary>
		public TypeExistsDescriptor AllTypes() => this.Type(Types.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public TypeExistsDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public TypeExistsDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public TypeExistsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public TypeExistsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public TypeExistsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public TypeExistsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesFlushForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-flush.html</pre></summary>
	public partial class FlushDescriptor  : RequestDescriptorBase<FlushDescriptor,FlushRequestParameters, IFlushRequest>, IFlushRequest
	{ 
		Indices IFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_flush</summary>
		public FlushDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string for all indices</summary>
		public FlushDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string for all indices</summary>
		public FlushDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string for all indices</summary>
		public FlushDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)</summary>
		public FlushDescriptor Force(bool force = true) => AssignParam(p=>p.Force(force));

		///<summary>If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is false and will cause an exception to be thrown on the shard level if another flush operation is already running.</summary>
		public FlushDescriptor WaitIfOngoing(bool wait_if_ongoing = true) => AssignParam(p=>p.WaitIfOngoing(wait_if_ongoing));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public FlushDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public FlushDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public FlushDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public FlushDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public FlushDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesFlushSyncedForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html</pre></summary>
	public partial class SyncedFlushDescriptor  : RequestDescriptorBase<SyncedFlushDescriptor,SyncedFlushRequestParameters, ISyncedFlushRequest>, ISyncedFlushRequest
	{ 
		Indices ISyncedFlushRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_flush/synced</summary>
		public SyncedFlushDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string for all indices</summary>
		public SyncedFlushDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string for all indices</summary>
		public SyncedFlushDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string for all indices</summary>
		public SyncedFlushDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SyncedFlushDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SyncedFlushDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SyncedFlushDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public SyncedFlushDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SyncedFlushDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html</pre></summary>
	public partial class GetIndexDescriptor  : RequestDescriptorBase<GetIndexDescriptor,GetIndexRequestParameters, IGetIndexRequest>, IGetIndexRequest
	{ 
		Indices IGetIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
		Features IGetIndexRequest.Feature => Self.RouteValues.Get<Features>("feature");
			/// <summary>/{index}</summary>
///<param name="index"> this parameter is required</param>
		public GetIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>A comma-separated list of index names</summary>
		public GetIndexDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names</summary>
		public GetIndexDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names</summary>
		public GetIndexDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of features</summary>
		public GetIndexDescriptor Feature(Features feature) => Assign(a=>a.RouteValues.Optional("feature", feature));

	
		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Ignore unavailable indexes (default: false)</summary>
		public GetIndexDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Ignore if a wildcard expression resolves to no concrete indices (default: false)</summary>
		public GetIndexDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether wildcard expressions should get expanded to open or closed indices (default: open)</summary>
		public GetIndexDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Whether to return version and creation date values in human-readable format.</summary>
		public GetIndexDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>The URL-encoded request definition</summary>
		public GetIndexDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetIndexDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetAliasForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class GetAliasDescriptor  : RequestDescriptorBase<GetAliasDescriptor,GetAliasRequestParameters, IGetAliasRequest>, IGetAliasRequest
	{ 
		Indices IGetAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetAliasRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_alias</summary>
		public GetAliasDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of alias names to return</summary>
		public GetAliasDescriptor Name(Names name) => Assign(a=>a.RouteValues.Optional("name", name));

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetAliasDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetAliasDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetAliasDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetAliasDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public GetAliasDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetAliasDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetAliasesForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class GetAliasesDescriptor  : RequestDescriptorBase<GetAliasesDescriptor,GetAliasesRequestParameters, IGetAliasesRequest>, IGetAliasesRequest
	{ 
		Indices IGetAliasesRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetAliasesRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_aliases</summary>
		public GetAliasesDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasesDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasesDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to filter aliases</summary>
		public GetAliasesDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of alias names to filter</summary>
		public GetAliasesDescriptor Name(Names name) => Assign(a=>a.RouteValues.Optional("name", name));

	
		///<summary>Explicit operation timeout</summary>
		public GetAliasesDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetAliasesDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public GetAliasesDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetAliasesDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetFieldMappingForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-field-mapping.html</pre></summary>
	public partial class GetFieldMappingDescriptor<T>  : RequestDescriptorBase<GetFieldMappingDescriptor<T>,GetFieldMappingRequestParameters, IGetFieldMappingRequest>, IGetFieldMappingRequest
	{ 
		Indices IGetFieldMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IGetFieldMappingRequest.Type => Self.RouteValues.Get<Types>("type");
		FieldNames IGetFieldMappingRequest.Fields => Self.RouteValues.Get<FieldNames>("fields");
			/// <summary>/_mapping/field/{fields}</summary>
///<param name="fields"> this parameter is required</param>
		public GetFieldMappingDescriptor(FieldNames fields) : base(r=>r.Required("fields", fields)){}
		

			///<summary>A comma-separated list of index names</summary>
		public GetFieldMappingDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names</summary>
		public GetFieldMappingDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names</summary>
		public GetFieldMappingDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types</summary>
		public GetFieldMappingDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types</summary>
		public GetFieldMappingDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types</summary>
		public GetFieldMappingDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>Whether the default mapping values should be returned as well</summary>
		public GetFieldMappingDescriptor<T> IncludeDefaults(bool include_defaults = true) => AssignParam(p=>p.IncludeDefaults(include_defaults));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetFieldMappingDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetFieldMappingDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetFieldMappingDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetFieldMappingDescriptor<T> Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public GetFieldMappingDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetFieldMappingDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetMappingForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html</pre></summary>
	public partial class GetMappingDescriptor<T>  : RequestDescriptorBase<GetMappingDescriptor<T>,GetMappingRequestParameters, IGetMappingRequest>, IGetMappingRequest
	{ 
		Indices IGetMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IGetMappingRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_mapping</summary>
		public GetMappingDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		

			///<summary>A comma-separated list of index names</summary>
		public GetMappingDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names</summary>
		public GetMappingDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names</summary>
		public GetMappingDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types</summary>
		public GetMappingDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types</summary>
		public GetMappingDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types</summary>
		public GetMappingDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetMappingDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetMappingDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetMappingDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetMappingDescriptor<T> Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public GetMappingDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetMappingDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetSettingsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html</pre></summary>
	public partial class GetIndexSettingsDescriptor  : RequestDescriptorBase<GetIndexSettingsDescriptor,GetIndexSettingsRequestParameters, IGetIndexSettingsRequest>, IGetIndexSettingsRequest
	{ 
		Indices IGetIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetIndexSettingsRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_settings</summary>
		public GetIndexSettingsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public GetIndexSettingsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public GetIndexSettingsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public GetIndexSettingsDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>The name of the settings that should be included</summary>
		public GetIndexSettingsDescriptor Name(Names name) => Assign(a=>a.RouteValues.Optional("name", name));

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetIndexSettingsDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetIndexSettingsDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetIndexSettingsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexSettingsDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexSettingsDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Whether to return version and creation date values in human-readable format.</summary>
		public GetIndexSettingsDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>The URL-encoded request definition</summary>
		public GetIndexSettingsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetIndexSettingsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class GetIndexTemplateDescriptor  : RequestDescriptorBase<GetIndexTemplateDescriptor,GetIndexTemplateRequestParameters, IGetIndexTemplateRequest>, IGetIndexTemplateRequest
	{ 
		Names IGetIndexTemplateRequest.Name => Self.RouteValues.Get<Names>("name");
			/// <summary>/_template</summary>
		public GetIndexTemplateDescriptor() : base(){}
		

			///<summary>The comma separated names of the index templates</summary>
		public GetIndexTemplateDescriptor Name(Names name) => Assign(a=>a.RouteValues.Optional("name", name));

	
		///<summary>Return settings in flat format (default: false)</summary>
		public GetIndexTemplateDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetIndexTemplateDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetIndexTemplateDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public GetIndexTemplateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetIndexTemplateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetUpgradeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeStatusDescriptor  : RequestDescriptorBase<UpgradeStatusDescriptor,UpgradeStatusRequestParameters, IUpgradeStatusRequest>, IUpgradeStatusRequest
	{ 
		Indices IUpgradeStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_upgrade</summary>
		public UpgradeStatusDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpgradeStatusDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpgradeStatusDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpgradeStatusDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpgradeStatusDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpgradeStatusDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpgradeStatusDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public UpgradeStatusDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>The URL-encoded request definition</summary>
		public UpgradeStatusDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public UpgradeStatusDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesGetWarmerForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html</pre></summary>
	public partial class GetWarmerDescriptor  : RequestDescriptorBase<GetWarmerDescriptor,GetWarmerRequestParameters, IGetWarmerRequest>, IGetWarmerRequest
	{ 
		Indices IGetWarmerRequest.Index => Self.RouteValues.Get<Indices>("index");
		Names IGetWarmerRequest.Name => Self.RouteValues.Get<Names>("name");
		Types IGetWarmerRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_warmer</summary>
		public GetWarmerDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</summary>
		public GetWarmerDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</summary>
		public GetWarmerDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices</summary>
		public GetWarmerDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>The name of the warmer (supports wildcards); leave empty to get all warmers</summary>
		public GetWarmerDescriptor Name(Names name) => Assign(a=>a.RouteValues.Optional("name", name));

		///<summary>A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</summary>
		public GetWarmerDescriptor Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</summary>
		public GetWarmerDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</summary>
		public GetWarmerDescriptor AllTypes() => this.Type(Types.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public GetWarmerDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public GetWarmerDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public GetWarmerDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetWarmerDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public GetWarmerDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetWarmerDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesOpen <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html</pre></summary>
	public partial class OpenIndexDescriptor  : RequestDescriptorBase<OpenIndexDescriptor,OpenIndexRequestParameters, IOpenIndexRequest>, IOpenIndexRequest
	{ 
		Indices IOpenIndexRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/{index}/_open</summary>
///<param name="index"> this parameter is required</param>
		public OpenIndexDescriptor(Indices index) : base(r=>r.Required("index", index)){}
		

			///<summary>A comma separated list of indices to open</summary>
		public OpenIndexDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma separated list of indices to open</summary>
		public OpenIndexDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma separated list of indices to open</summary>
		public OpenIndexDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Explicit operation timeout</summary>
		public OpenIndexDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public OpenIndexDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OpenIndexDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OpenIndexDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OpenIndexDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public OpenIndexDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public OpenIndexDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesOptimizeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-optimize.html</pre></summary>
	public partial class OptimizeDescriptor  : RequestDescriptorBase<OptimizeDescriptor,OptimizeRequestParameters, IOptimizeRequest>, IOptimizeRequest
	{ 
		Indices IOptimizeRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_optimize</summary>
		public OptimizeDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public OptimizeDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public OptimizeDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public OptimizeDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Specify whether the index should be flushed after performing the operation (default: true)</summary>
		public OptimizeDescriptor Flush(bool flush = true) => AssignParam(p=>p.Flush(flush));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public OptimizeDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public OptimizeDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public OptimizeDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The number of segments the index should be merged into (default: dynamic)</summary>
		public OptimizeDescriptor MaxNumSegments(long max_num_segments) => AssignParam(p=>p.MaxNumSegments(max_num_segments));

		///<summary>Specify whether the operation should only expunge deleted documents</summary>
		public OptimizeDescriptor OnlyExpungeDeletes(bool only_expunge_deletes = true) => AssignParam(p=>p.OnlyExpungeDeletes(only_expunge_deletes));

		///<summary>TODO: ?</summary>
		public OptimizeDescriptor OperationThreading(string operation_threading) => AssignParam(p=>p.OperationThreading(operation_threading));

		///<summary>Specify whether the request should block until the merge process is finished (default: true)</summary>
		public OptimizeDescriptor WaitForMerge(bool wait_for_merge = true) => AssignParam(p=>p.WaitForMerge(wait_for_merge));

		///<summary>The URL-encoded request definition</summary>
		public OptimizeDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public OptimizeDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesPutAlias <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class PutAliasDescriptor  : RequestDescriptorBase<PutAliasDescriptor,PutAliasRequestParameters, IPutAliasRequest>, IPutAliasRequest
	{ 
		Indices IPutAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
		Name IPutAliasRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/{index}/_alias/{name}</summary>
///<param name="index"> this parameter is required</param>		
///<param name="name"> this parameter is required</param>
		public PutAliasDescriptor(Indices index, Name name) : base(r=>r.Required("index", index).Required("name", name)){}
		

			///<summary>A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public PutAliasDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public PutAliasDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.</summary>
		public PutAliasDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Explicit timestamp for the document</summary>
		public PutAliasDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public PutAliasDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public PutAliasDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PutAliasDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesPutMapping <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html</pre></summary>
	public partial class PutMappingDescriptor<T>  : RequestDescriptorBase<PutMappingDescriptor<T>,PutMappingRequestParameters, IPutMappingRequest>, IPutMappingRequest
	{ 
		Indices IPutMappingRequest.Index => Self.RouteValues.Get<Indices>("index");
		TypeName IPutMappingRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/_mapping</summary>
///<param name="type"> this parameter is required</param>
		public PutMappingDescriptor(TypeName type) : base(r=>r.Required("type", type)){}
		

			///<summary>A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</summary>
		public PutMappingDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</summary>
		public PutMappingDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.</summary>
		public PutMappingDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>The name of the document type</summary>
		public PutMappingDescriptor<T> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The name of the document type</summary>
		public PutMappingDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Explicit operation timeout</summary>
		public PutMappingDescriptor<T> Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public PutMappingDescriptor<T> MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PutMappingDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PutMappingDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PutMappingDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Whether to update the mapping for all fields with the same name across all types or not</summary>
		public PutMappingDescriptor<T> UpdateAllTypes(bool update_all_types = true) => AssignParam(p=>p.UpdateAllTypes(update_all_types));

		///<summary>The URL-encoded request definition</summary>
		public PutMappingDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PutMappingDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesPutSettingsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html</pre></summary>
	public partial class UpdateIndexSettingsDescriptor  : RequestDescriptorBase<UpdateIndexSettingsDescriptor,UpdateIndexSettingsRequestParameters, IUpdateIndexSettingsRequest>, IUpdateIndexSettingsRequest
	{ 
		Indices IUpdateIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_settings</summary>
		public UpdateIndexSettingsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpdateIndexSettingsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpdateIndexSettingsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpdateIndexSettingsDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Specify timeout for connection to master</summary>
		public UpdateIndexSettingsDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpdateIndexSettingsDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpdateIndexSettingsDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpdateIndexSettingsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Return settings in flat format (default: false)</summary>
		public UpdateIndexSettingsDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>The URL-encoded request definition</summary>
		public UpdateIndexSettingsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public UpdateIndexSettingsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesPutTemplateForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html</pre></summary>
	public partial class PutIndexTemplateDescriptor  : RequestDescriptorBase<PutIndexTemplateDescriptor,PutIndexTemplateRequestParameters, IPutIndexTemplateRequest>, IPutIndexTemplateRequest
	{ 
		Name IPutIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");
			/// <summary>/_template/{name}</summary>
///<param name="name"> this parameter is required</param>
		public PutIndexTemplateDescriptor(Name name) : base(r=>r.Required("name", name)){}
		

		
		///<summary>Whether the index template should only be added if new or can also replace an existing one</summary>
		public PutIndexTemplateDescriptor Create(bool create = true) => AssignParam(p=>p.Create(create));

		///<summary>Explicit operation timeout</summary>
		public PutIndexTemplateDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public PutIndexTemplateDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Return settings in flat format (default: false)</summary>
		public PutIndexTemplateDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>The URL-encoded request definition</summary>
		public PutIndexTemplateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PutIndexTemplateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesPutWarmerForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html</pre></summary>
	public partial class PutWarmerDescriptor  : RequestDescriptorBase<PutWarmerDescriptor,PutWarmerRequestParameters, IPutWarmerRequest>, IPutWarmerRequest
	{ 
		Indices IPutWarmerRequest.Index => Self.RouteValues.Get<Indices>("index");
		Name IPutWarmerRequest.Name => Self.RouteValues.Get<Name>("name");
		Types IPutWarmerRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_warmer/{name}</summary>
///<param name="name"> this parameter is required</param>
		public PutWarmerDescriptor(Name name) : base(r=>r.Required("name", name)){}
		

			///<summary>A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</summary>
		public PutWarmerDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</summary>
		public PutWarmerDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices</summary>
		public PutWarmerDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</summary>
		public PutWarmerDescriptor Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</summary>
		public PutWarmerDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types</summary>
		public PutWarmerDescriptor AllTypes() => this.Type(Types.All);

	
		///<summary>Specify timeout for connection to master</summary>
		public PutWarmerDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm</summary>
		public PutWarmerDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)</summary>
		public PutWarmerDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.</summary>
		public PutWarmerDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Specify whether the request to be warmed should use the request cache, defaults to index level setting</summary>
		public PutWarmerDescriptor RequestCache(bool request_cache = true) => AssignParam(p=>p.RequestCache(request_cache));

		///<summary>The URL-encoded request definition</summary>
		public PutWarmerDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PutWarmerDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesRecoveryForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html</pre></summary>
	public partial class RecoveryStatusDescriptor  : RequestDescriptorBase<RecoveryStatusDescriptor,RecoveryStatusRequestParameters, IRecoveryStatusRequest>, IRecoveryStatusRequest
	{ 
		Indices IRecoveryStatusRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_recovery</summary>
		public RecoveryStatusDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public RecoveryStatusDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public RecoveryStatusDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public RecoveryStatusDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether to display detailed information about shard recovery</summary>
		public RecoveryStatusDescriptor Detailed(bool detailed = true) => AssignParam(p=>p.Detailed(detailed));

		///<summary>Display only those recoveries that are currently on-going</summary>
		public RecoveryStatusDescriptor ActiveOnly(bool active_only = true) => AssignParam(p=>p.ActiveOnly(active_only));

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public RecoveryStatusDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>The URL-encoded request definition</summary>
		public RecoveryStatusDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public RecoveryStatusDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesRefreshForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-refresh.html</pre></summary>
	public partial class RefreshDescriptor  : RequestDescriptorBase<RefreshDescriptor,RefreshRequestParameters, IRefreshRequest>, IRefreshRequest
	{ 
		Indices IRefreshRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_refresh</summary>
		public RefreshDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public RefreshDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public RefreshDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public RefreshDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public RefreshDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public RefreshDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public RefreshDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Force a refresh even if not required</summary>
		public RefreshDescriptor Force(bool force = true) => AssignParam(p=>p.Force(force));

		///<summary>TODO: ?</summary>
		public RefreshDescriptor OperationThreading(string operation_threading) => AssignParam(p=>p.OperationThreading(operation_threading));

		///<summary>The URL-encoded request definition</summary>
		public RefreshDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public RefreshDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesSegmentsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-segments.html</pre></summary>
	public partial class SegmentsDescriptor  : RequestDescriptorBase<SegmentsDescriptor,SegmentsRequestParameters, ISegmentsRequest>, ISegmentsRequest
	{ 
		Indices ISegmentsRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_segments</summary>
		public SegmentsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public SegmentsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public SegmentsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public SegmentsDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SegmentsDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SegmentsDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SegmentsDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public SegmentsDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>TODO: ?</summary>
		public SegmentsDescriptor OperationThreading(string operation_threading) => AssignParam(p=>p.OperationThreading(operation_threading));

		///<summary>The URL-encoded request definition</summary>
		public SegmentsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SegmentsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesShardStoresForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shards-stores.html</pre></summary>
	public partial class IndicesShardStoresDescriptor  : RequestDescriptorBase<IndicesShardStoresDescriptor,IndicesShardStoresRequestParameters, IIndicesShardStoresRequest>, IIndicesShardStoresRequest
	{ 
		Indices IIndicesShardStoresRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_shard_stores</summary>
		public IndicesShardStoresDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public IndicesShardStoresDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public IndicesShardStoresDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public IndicesShardStoresDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>A comma-separated list of statuses used to filter on shards to get store information for</summary>
		public IndicesShardStoresDescriptor Status(params string[] status) => AssignParam(p=>p.Status(status));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public IndicesShardStoresDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public IndicesShardStoresDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public IndicesShardStoresDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>TODO: ?</summary>
		public IndicesShardStoresDescriptor OperationThreading(string operation_threading) => AssignParam(p=>p.OperationThreading(operation_threading));

		///<summary>The URL-encoded request definition</summary>
		public IndicesShardStoresDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public IndicesShardStoresDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));

		//TODO THIS METHOD IS UNMAPPED!
		
	
	}
	
	///<summary>descriptor for IndicesStatsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html</pre></summary>
	public partial class IndicesStatsDescriptor  : RequestDescriptorBase<IndicesStatsDescriptor,IndicesStatsRequestParameters, IIndicesStatsRequest>, IIndicesStatsRequest
	{ 
		Indices IIndicesStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Metrics IIndicesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
			/// <summary>/_stats</summary>
		public IndicesStatsDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public IndicesStatsDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public IndicesStatsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public IndicesStatsDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>Limit the information returned the specific metrics.</summary>
		public IndicesStatsDescriptor Metric(IndicesStatsMetric metric) => Assign(a=>a.RouteValues.Optional("metric", (Metrics)metric));

	
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields(params string[] completion_fields) => AssignParam(p=>p.CompletionFields(completion_fields));
			
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._CompletionFields(fields));

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields(params string[] fielddata_fields) => AssignParam(p=>p.FielddataFields(fielddata_fields));
			
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._FielddataFields(fields));

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public IndicesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._Fields(fields));

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public IndicesStatsDescriptor Groups(params string[] groups) => AssignParam(p=>p.Groups(groups));

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public IndicesStatsDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>Return stats aggregated at cluster, index or shard level</summary>
		public IndicesStatsDescriptor Level(Level level) => AssignParam(p=>p.Level(level));

		///<summary>The URL-encoded request definition</summary>
		public IndicesStatsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public IndicesStatsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesUpdateAliasesForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html</pre></summary>
	public partial class BulkAliasDescriptor  : RequestDescriptorBase<BulkAliasDescriptor,BulkAliasRequestParameters, IBulkAliasRequest>, IBulkAliasRequest
	{ 
			
		///<summary>Request timeout</summary>
		public BulkAliasDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Specify timeout for connection to master</summary>
		public BulkAliasDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public BulkAliasDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public BulkAliasDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesUpgradeForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html</pre></summary>
	public partial class UpgradeDescriptor  : RequestDescriptorBase<UpgradeDescriptor,UpgradeRequestParameters, IUpgradeRequest>, IUpgradeRequest
	{ 
		Indices IUpgradeRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_upgrade</summary>
		public UpgradeDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpgradeDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpgradeDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices</summary>
		public UpgradeDescriptor AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public UpgradeDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public UpgradeDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public UpgradeDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Specify whether the request should block until the all segments are upgraded (default: false)</summary>
		public UpgradeDescriptor WaitForCompletion(bool wait_for_completion = true) => AssignParam(p=>p.WaitForCompletion(wait_for_completion));

		///<summary>If true, only ancient (an older Lucene major release) segments will be upgraded</summary>
		public UpgradeDescriptor OnlyAncientSegments(bool only_ancient_segments = true) => AssignParam(p=>p.OnlyAncientSegments(only_ancient_segments));

		///<summary>The URL-encoded request definition</summary>
		public UpgradeDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public UpgradeDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for IndicesValidateQueryForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html</pre></summary>
	public partial class ValidateQueryDescriptor<T>  : RequestDescriptorBase<ValidateQueryDescriptor<T>,ValidateQueryRequestParameters, IValidateQueryRequest>, IValidateQueryRequest
	{ 
		Indices IValidateQueryRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IValidateQueryRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_validate/query</summary>
		public ValidateQueryDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		

			///<summary>A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</summary>
		public ValidateQueryDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</summary>
		public ValidateQueryDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</summary>
		public ValidateQueryDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</summary>
		public ValidateQueryDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</summary>
		public ValidateQueryDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types</summary>
		public ValidateQueryDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>Return detailed information about the error</summary>
		public ValidateQueryDescriptor<T> Explain(bool explain = true) => AssignParam(p=>p.Explain(explain));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public ValidateQueryDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public ValidateQueryDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public ValidateQueryDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>TODO: ?</summary>
		public ValidateQueryDescriptor<T> OperationThreading(string operation_threading) => AssignParam(p=>p.OperationThreading(operation_threading));

		///<summary>Query in the Lucene query string syntax</summary>
		public ValidateQueryDescriptor<T> QueryOnQueryString(string query_on_query_string) => AssignParam(p=>p.QueryOnQueryString(query_on_query_string));

		///<summary>The analyzer to use for the query string</summary>
		public ValidateQueryDescriptor<T> Analyzer(string analyzer) => AssignParam(p=>p.Analyzer(analyzer));

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public ValidateQueryDescriptor<T> AnalyzeWildcard(bool analyze_wildcard = true) => AssignParam(p=>p.AnalyzeWildcard(analyze_wildcard));

		///<summary>The default operator for query string query (AND or OR)</summary>
		public ValidateQueryDescriptor<T> DefaultOperator(DefaultOperator default_operator) => AssignParam(p=>p.DefaultOperator(default_operator));

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public ValidateQueryDescriptor<T> Df(string df) => AssignParam(p=>p.Df(df));

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public ValidateQueryDescriptor<T> Lenient(bool lenient = true) => AssignParam(p=>p.Lenient(lenient));

		///<summary>Specify whether query terms should be lowercased</summary>
		public ValidateQueryDescriptor<T> LowercaseExpandedTerms(bool lowercase_expanded_terms = true) => AssignParam(p=>p.LowercaseExpandedTerms(lowercase_expanded_terms));

		///<summary>Provide a more detailed explanation showing the actual Lucene query that will be executed.</summary>
		public ValidateQueryDescriptor<T> Rewrite(bool rewrite = true) => AssignParam(p=>p.Rewrite(rewrite));

		///<summary>The URL-encoded request definition</summary>
		public ValidateQueryDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ValidateQueryDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Info <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class RootNodeInfoDescriptor  : RequestDescriptorBase<RootNodeInfoDescriptor,RootNodeInfoRequestParameters, IRootNodeInfoRequest>, IRootNodeInfoRequest
	{ 
			
		///<summary>The URL-encoded request definition</summary>
		public RootNodeInfoDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public RootNodeInfoDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Mget <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html</pre></summary>
	public partial class MultiGetDescriptor  : RequestDescriptorBase<MultiGetDescriptor,MultiGetRequestParameters, IMultiGetRequest>, IMultiGetRequest
	{ 
		IndexName IMultiGetRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiGetRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_mget</summary>
		public MultiGetDescriptor() : base(){}
		

			///<summary>The name of the index</summary>
		public MultiGetDescriptor Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public MultiGetDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document</summary>
		public MultiGetDescriptor Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document</summary>
		public MultiGetDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>A comma-separated list of fields to return in the response</summary>
		public MultiGetDescriptor Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields to return in the response</summary>
		public MultiGetDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._Fields(fields));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public MultiGetDescriptor Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specify whether to perform the operation in realtime or search mode</summary>
		public MultiGetDescriptor Realtime(bool realtime = true) => AssignParam(p=>p.Realtime(realtime));

		///<summary>Refresh the shard containing the document before performing the operation</summary>
		public MultiGetDescriptor Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>True or false to return the _source field or not, or a list of fields to return</summary>
		public MultiGetDescriptor SourceEnabled(params string[] source_enabled) => AssignParam(p=>p.SourceEnabled(source_enabled));

		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExclude(params string[] source_exclude) => AssignParam(p=>p.SourceExclude(source_exclude));
			
		///<summary>A list of fields to exclude from the returned _source field</summary>
		public MultiGetDescriptor SourceExclude<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._SourceExclude(fields));

		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceInclude(params string[] source_include) => AssignParam(p=>p.SourceInclude(source_include));
			
		///<summary>A list of fields to extract and return from the _source field</summary>
		public MultiGetDescriptor SourceInclude<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._SourceInclude(fields));

		///<summary>The URL-encoded request definition</summary>
		public MultiGetDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public MultiGetDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Mpercolate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html</pre></summary>
	public partial class MultiPercolateDescriptor  : RequestDescriptorBase<MultiPercolateDescriptor,MultiPercolateRequestParameters, IMultiPercolateRequest>, IMultiPercolateRequest
	{ 
		IndexName IMultiPercolateRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiPercolateRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_mpercolate</summary>
		public MultiPercolateDescriptor() : base(){}
		

			///<summary>The index of the document being count percolated to use as default</summary>
		public MultiPercolateDescriptor Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The index of the document being count percolated to use as default</summary>
		public MultiPercolateDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document being percolated to use as default.</summary>
		public MultiPercolateDescriptor Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document being percolated to use as default.</summary>
		public MultiPercolateDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public MultiPercolateDescriptor IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public MultiPercolateDescriptor AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public MultiPercolateDescriptor ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public MultiPercolateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public MultiPercolateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Msearch <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html</pre></summary>
	public partial class MultiSearchDescriptor  : RequestDescriptorBase<MultiSearchDescriptor,MultiSearchRequestParameters, IMultiSearchRequest>, IMultiSearchRequest
	{ 
		Indices IMultiSearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types IMultiSearchRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_msearch</summary>
		public MultiSearchDescriptor() {}
		

			///<summary>A comma-separated list of index names to use as default</summary>
		public MultiSearchDescriptor Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to use as default</summary>
		public MultiSearchDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to use as default</summary>
		public MultiSearchDescriptor AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to use as default</summary>
		public MultiSearchDescriptor Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to use as default</summary>
		public MultiSearchDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to use as default</summary>
		public MultiSearchDescriptor AllTypes() => this.Type(Types.All);

	
		///<summary>Search operation type</summary>
		public MultiSearchDescriptor SearchType(SearchType search_type) => AssignParam(p=>p.SearchType(search_type));

		///<summary>The URL-encoded request definition</summary>
		public MultiSearchDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public MultiSearchDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Mtermvectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html</pre></summary>
	public partial class MultiTermVectorsDescriptor  : RequestDescriptorBase<MultiTermVectorsDescriptor,MultiTermVectorsRequestParameters, IMultiTermVectorsRequest>, IMultiTermVectorsRequest
	{ 
		IndexName IMultiTermVectorsRequest.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IMultiTermVectorsRequest.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/_mtermvectors</summary>
		public MultiTermVectorsDescriptor() : base(){}
		

			///<summary>The index in which the document resides.</summary>
		public MultiTermVectorsDescriptor Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The index in which the document resides.</summary>
		public MultiTermVectorsDescriptor Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document.</summary>
		public MultiTermVectorsDescriptor Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document.</summary>
		public MultiTermVectorsDescriptor Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor TermStatistics(bool term_statistics = true) => AssignParam(p=>p.TermStatistics(term_statistics));

		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor FieldStatistics(bool field_statistics = true) => AssignParam(p=>p.FieldStatistics(field_statistics));

		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._Fields(fields));

		///<summary>Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Offsets(bool offsets = true) => AssignParam(p=>p.Offsets(offsets));

		///<summary>Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Positions(bool positions = true) => AssignParam(p=>p.Positions(positions));

		///<summary>Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Payloads(bool payloads = true) => AssignParam(p=>p.Payloads(payloads));

		///<summary>Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specific routing value. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Parent id of documents. Applies to all returned documents unless otherwise specified in body &quot;params&quot; or &quot;docs&quot;.</summary>
		public MultiTermVectorsDescriptor Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Specifies if requests are real-time as opposed to near-real-time (default: true).</summary>
		public MultiTermVectorsDescriptor Realtime(bool realtime = true) => AssignParam(p=>p.Realtime(realtime));

		///<summary>Explicit version number for concurrency control</summary>
		public MultiTermVectorsDescriptor Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public MultiTermVectorsDescriptor VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public MultiTermVectorsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public MultiTermVectorsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for NodesHotThreadsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-hot-threads.html</pre></summary>
	public partial class NodesHotThreadsDescriptor  : RequestDescriptorBase<NodesHotThreadsDescriptor,NodesHotThreadsRequestParameters, INodesHotThreadsRequest>, INodesHotThreadsRequest
	{ 
		NodeIds INodesHotThreadsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_cluster/nodes/hotthreads</summary>
		public NodesHotThreadsDescriptor() : base(){}
		

			///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesHotThreadsDescriptor NodeId(NodeIds nodeId) => Assign(a=>a.RouteValues.Optional("node_id", nodeId));

	
		///<summary>The interval for the second sampling of threads</summary>
		public NodesHotThreadsDescriptor Interval(string interval) => AssignParam(p=>p.Interval(interval));

		///<summary>Number of samples of thread stacktrace (default: 10)</summary>
		public NodesHotThreadsDescriptor Snapshots(long snapshots) => AssignParam(p=>p.Snapshots(snapshots));

		///<summary>Specify the number of threads to provide information for (default: 3)</summary>
		public NodesHotThreadsDescriptor Threads(long threads) => AssignParam(p=>p.Threads(threads));

		///<summary>Don&#39;t show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)</summary>
		public NodesHotThreadsDescriptor IgnoreIdleThreads(bool ignore_idle_threads = true) => AssignParam(p=>p.IgnoreIdleThreads(ignore_idle_threads));

		///<summary>The type to sample (default: cpu)</summary>
		public NodesHotThreadsDescriptor ThreadType(ThreadType thread_type) => AssignParam(p=>p.ThreadType(thread_type));

		///<summary>Explicit operation timeout</summary>
		public NodesHotThreadsDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public NodesHotThreadsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public NodesHotThreadsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for NodesInfoForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-info.html</pre></summary>
	public partial class NodesInfoDescriptor  : RequestDescriptorBase<NodesInfoDescriptor,NodesInfoRequestParameters, INodesInfoRequest>, INodesInfoRequest
	{ 
		NodeIds INodesInfoRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
		Metrics INodesInfoRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
			/// <summary>/_nodes</summary>
		public NodesInfoDescriptor() : base(){}
		

			///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesInfoDescriptor NodeId(NodeIds nodeId) => Assign(a=>a.RouteValues.Optional("node_id", nodeId));

		///<summary>A comma-separated list of metrics you wish returned. Leave empty to return all.</summary>
		public NodesInfoDescriptor Metric(NodesInfoMetric metric) => Assign(a=>a.RouteValues.Optional("metric", (Metrics)metric));

	
		///<summary>Return settings in flat format (default: false)</summary>
		public NodesInfoDescriptor FlatSettings(bool flat_settings = true) => AssignParam(p=>p.FlatSettings(flat_settings));

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public NodesInfoDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>Explicit operation timeout</summary>
		public NodesInfoDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public NodesInfoDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public NodesInfoDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for NodesStatsForAll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-stats.html</pre></summary>
	public partial class NodesStatsDescriptor  : RequestDescriptorBase<NodesStatsDescriptor,NodesStatsRequestParameters, INodesStatsRequest>, INodesStatsRequest
	{ 
		Metrics INodesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");
		IndexMetrics INodesStatsRequest.IndexMetric => Self.RouteValues.Get<IndexMetrics>("index_metric");
		NodeIds INodesStatsRequest.NodeId => Self.RouteValues.Get<NodeIds>("node_id");
			/// <summary>/_nodes/stats</summary>
		public NodesStatsDescriptor() : base(){}
		

			///<summary>Limit the information returned to the specified metrics</summary>
		public NodesStatsDescriptor Metric(NodesStatsMetric metric) => Assign(a=>a.RouteValues.Optional("metric", (Metrics)metric));

		///<summary>Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.</summary>
		public NodesStatsDescriptor IndexMetric(NodesStatsIndexMetric indexMetric) => Assign(a=>a.RouteValues.Optional("index_metric", (IndexMetrics)indexMetric));

		///<summary>A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes</summary>
		public NodesStatsDescriptor NodeId(NodeIds nodeId) => Assign(a=>a.RouteValues.Optional("node_id", nodeId));

	
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields(params string[] completion_fields) => AssignParam(p=>p.CompletionFields(completion_fields));
			
		///<summary>A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor CompletionFields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._CompletionFields(fields));

		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields(params string[] fielddata_fields) => AssignParam(p=>p.FielddataFields(fielddata_fields));
			
		///<summary>A comma-separated list of fields for `fielddata` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor FielddataFields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._FielddataFields(fields));

		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)</summary>
		public NodesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields) where T : class =>
			AssignParam(p=>p._Fields(fields));

		///<summary>A comma-separated list of search groups for `search` index metric</summary>
		public NodesStatsDescriptor Groups(bool groups = true) => AssignParam(p=>p.Groups(groups));

		///<summary>Whether to return time and byte values in human-readable format.</summary>
		public NodesStatsDescriptor Human(bool human = true) => AssignParam(p=>p.Human(human));

		///<summary>Return indices stats aggregated at node, index or shard level</summary>
		public NodesStatsDescriptor Level(Level level) => AssignParam(p=>p.Level(level));

		///<summary>A comma-separated list of document types for the `indexing` index metric</summary>
		public NodesStatsDescriptor Types(params string[] types) => AssignParam(p=>p.Types(types));

		///<summary>Explicit operation timeout</summary>
		public NodesStatsDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public NodesStatsDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public NodesStatsDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Percolate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html</pre></summary>
	public partial class PercolateDescriptor<TDocument>  : RequestDescriptorBase<PercolateDescriptor<TDocument>,PercolateRequestParameters, IPercolateRequest<TDocument>>, IPercolateRequest<TDocument>
	{ 
		IndexName IPercolateRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IPercolateRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
		Id IPercolateRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/{index}/{type}/_percolate</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>
		public PercolateDescriptor(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}/_percolate</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public PercolateDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>The index of the document being percolated.</summary>
		public PercolateDescriptor<TDocument> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The index of the document being percolated.</summary>
		public PercolateDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document being percolated.</summary>
		public PercolateDescriptor<TDocument> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document being percolated.</summary>
		public PercolateDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

		///<summary>Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.</summary>
		public PercolateDescriptor<TDocument> Id(Id id) => Assign(a=>a.RouteValues.Optional("id", id));

	
		///<summary>A comma-separated list of specific routing values</summary>
		public PercolateDescriptor<TDocument> Routing(params string[] routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public PercolateDescriptor<TDocument> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public PercolateDescriptor<TDocument> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public PercolateDescriptor<TDocument> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public PercolateDescriptor<TDocument> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The index to percolate the document into. Defaults to index.</summary>
		public PercolateDescriptor<TDocument> PercolateIndex(string percolate_index) => AssignParam(p=>p.PercolateIndex(percolate_index));

		///<summary>The type to percolate document into. Defaults to type.</summary>
		public PercolateDescriptor<TDocument> PercolateType(string percolate_type) => AssignParam(p=>p.PercolateType(percolate_type));

		///<summary>The routing value to use when percolating the existing document.</summary>
		public PercolateDescriptor<TDocument> PercolateRouting(string percolate_routing) => AssignParam(p=>p.PercolateRouting(percolate_routing));

		///<summary>Which shard to prefer when executing the percolate request.</summary>
		public PercolateDescriptor<TDocument> PercolatePreference(string percolate_preference) => AssignParam(p=>p.PercolatePreference(percolate_preference));

		///<summary>Return an array of matching query IDs instead of objects</summary>
		public PercolateDescriptor<TDocument> PercolateFormat(PercolateFormat percolate_format) => AssignParam(p=>p.PercolateFormat(percolate_format));

		///<summary>Explicit version number for concurrency control</summary>
		public PercolateDescriptor<TDocument> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public PercolateDescriptor<TDocument> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public PercolateDescriptor<TDocument> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PercolateDescriptor<TDocument> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Ping <pre>http://www.elastic.co/guide/</pre></summary>
	public partial class PingDescriptor  : RequestDescriptorBase<PingDescriptor,PingRequestParameters, IPingRequest>, IPingRequest
	{ 
			
		///<summary>The URL-encoded request definition</summary>
		public PingDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PingDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for PutScript <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html</pre></summary>
	public partial class PutScriptDescriptor  : RequestDescriptorBase<PutScriptDescriptor,PutScriptRequestParameters, IPutScriptRequest>, IPutScriptRequest
	{ 
		Id IPutScriptRequest.Id => Self.RouteValues.Get<Id>("id");
		Name IPutScriptRequest.Lang => Self.RouteValues.Get<Name>("lang");
			/// <summary>/_scripts/{lang}/{id}</summary>
///<param name="lang"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public PutScriptDescriptor(Name lang, Id id) : base(r=>r.Required("lang", lang).Required("id", id)){}
		

		
		///<summary>Explicit operation type</summary>
		public PutScriptDescriptor OpType(OpType op_type) => AssignParam(p=>p.OpType(op_type));

		///<summary>Explicit version number for concurrency control</summary>
		public PutScriptDescriptor Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public PutScriptDescriptor VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public PutScriptDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PutScriptDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for PutTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class PutSearchTemplateDescriptor  : RequestDescriptorBase<PutSearchTemplateDescriptor,PutSearchTemplateRequestParameters, IPutSearchTemplateRequest>, IPutSearchTemplateRequest
	{ 
		Id IPutSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_search/template/{id}</summary>
///<param name="id"> this parameter is required</param>
		public PutSearchTemplateDescriptor(Id id) : base(r=>r.Required("id", id)){}
		

		
		///<summary>Explicit operation type</summary>
		public PutSearchTemplateDescriptor OpType(OpType op_type) => AssignParam(p=>p.OpType(op_type));

		///<summary>Explicit version number for concurrency control</summary>
		public PutSearchTemplateDescriptor Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public PutSearchTemplateDescriptor VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public PutSearchTemplateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public PutSearchTemplateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for RenderSearchTemplate <pre>http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-template.html</pre></summary>
	public partial class RenderSearchTemplateDescriptor  : RequestDescriptorBase<RenderSearchTemplateDescriptor,RenderSearchTemplateRequestParameters, IRenderSearchTemplateRequest>, IRenderSearchTemplateRequest
	{ 
		Id IRenderSearchTemplateRequest.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/_render/template</summary>
		public RenderSearchTemplateDescriptor() : base(){}
		

			///<summary>The id of the stored search template</summary>
		public RenderSearchTemplateDescriptor Id(Id id) => Assign(a=>a.RouteValues.Optional("id", id));

	
		///<summary>The URL-encoded request definition</summary>
		public RenderSearchTemplateDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public RenderSearchTemplateDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));

		//TODO THIS METHOD IS UNMAPPED!
		
	
	}
	
	///<summary>descriptor for Scroll <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html</pre></summary>
	public partial class ScrollDescriptor<T>  : RequestDescriptorBase<ScrollDescriptor<T>,ScrollRequestParameters, IScrollRequest>, IScrollRequest
	{ 
		ScrollId IScrollRequest.ScrollId => Self.RouteValues.Get<ScrollId>("scroll_id");
			/// <summary>/_search/scroll</summary>
		public ScrollDescriptor() : base(){}
		

			///<summary>The scroll ID</summary>
		public ScrollDescriptor<T> ScrollId(ScrollId scrollId) => Assign(a=>a.RouteValues.Optional("scroll_id", scrollId));

	
		///<summary>The URL-encoded request definition</summary>
		public ScrollDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public ScrollDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Search <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html</pre></summary>
	public partial class SearchDescriptor<T>  : RequestDescriptorBase<SearchDescriptor<T>,SearchRequestParameters, ISearchRequest>, ISearchRequest
	{ 
		Indices ISearchRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search</summary>
		public SearchDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		

			///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>The analyzer to use for the query string</summary>
		public SearchDescriptor<T> Analyzer(string analyzer) => AssignParam(p=>p.Analyzer(analyzer));

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public SearchDescriptor<T> AnalyzeWildcard(bool analyze_wildcard = true) => AssignParam(p=>p.AnalyzeWildcard(analyze_wildcard));

		///<summary>The default operator for query string query (AND or OR)</summary>
		public SearchDescriptor<T> DefaultOperator(DefaultOperator default_operator) => AssignParam(p=>p.DefaultOperator(default_operator));

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public SearchDescriptor<T> Df(string df) => AssignParam(p=>p.Df(df));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public SearchDescriptor<T> Lenient(bool lenient = true) => AssignParam(p=>p.Lenient(lenient));

		///<summary>Specify whether query terms should be lowercased</summary>
		public SearchDescriptor<T> LowercaseExpandedTerms(bool lowercase_expanded_terms = true) => AssignParam(p=>p.LowercaseExpandedTerms(lowercase_expanded_terms));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>A comma-separated list of specific routing values</summary>
		public SearchDescriptor<T> Routing(params string[] routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchDescriptor<T> Scroll(string scroll) => AssignParam(p=>p.Scroll(scroll));

		///<summary>Search operation type</summary>
		public SearchDescriptor<T> SearchType(SearchType search_type) => AssignParam(p=>p.SearchType(search_type));

		///<summary>Specific &#39;tag&#39; of the request for logging and statistical purposes</summary>
		public SearchDescriptor<T> Stats(params string[] stats) => AssignParam(p=>p.Stats(stats));

		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(string suggest_field) => AssignParam(p=>p.SuggestField(suggest_field));

		///<summary>Specify which field to use for suggestions</summary>
		public SearchDescriptor<T> SuggestField(Expression<Func<T, object>> field)  =>
			AssignParam(p=>p._SuggestField(field));

		///<summary>Specify suggest mode</summary>
		public SearchDescriptor<T> SuggestMode(SuggestMode suggest_mode) => AssignParam(p=>p.SuggestMode(suggest_mode));

		///<summary>How many suggestions to return in response</summary>
		public SearchDescriptor<T> SuggestSize(long suggest_size) => AssignParam(p=>p.SuggestSize(suggest_size));

		///<summary>The source text for which the suggestions should be returned</summary>
		public SearchDescriptor<T> SuggestText(string suggest_text) => AssignParam(p=>p.SuggestText(suggest_text));

		///<summary>Specify if request cache should be used for this request or not, defaults to index level setting</summary>
		public SearchDescriptor<T> RequestCache(bool request_cache = true) => AssignParam(p=>p.RequestCache(request_cache));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SearchDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SearchExists <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-exists.html</pre></summary>
	public partial class SearchExistsDescriptor<T>  : RequestDescriptorBase<SearchExistsDescriptor<T>,SearchExistsRequestParameters, ISearchExistsRequest>, ISearchExistsRequest
	{ 
		Indices ISearchExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchExistsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search/exists</summary>
		public SearchExistsDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		

			///<summary>A comma-separated list of indices to restrict the results</summary>
		public SearchExistsDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of indices to restrict the results</summary>
		public SearchExistsDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of indices to restrict the results</summary>
		public SearchExistsDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of types to restrict the results</summary>
		public SearchExistsDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of types to restrict the results</summary>
		public SearchExistsDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of types to restrict the results</summary>
		public SearchExistsDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchExistsDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchExistsDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchExistsDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Include only documents with a specific `_score` value in the result</summary>
		public SearchExistsDescriptor<T> MinScore(double min_score) => AssignParam(p=>p.MinScore(min_score));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchExistsDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specific routing value</summary>
		public SearchExistsDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Query in the Lucene query string syntax</summary>
		public SearchExistsDescriptor<T> QueryOnQueryString(string query_on_query_string) => AssignParam(p=>p.QueryOnQueryString(query_on_query_string));

		///<summary>The analyzer to use for the query string</summary>
		public SearchExistsDescriptor<T> Analyzer(string analyzer) => AssignParam(p=>p.Analyzer(analyzer));

		///<summary>Specify whether wildcard and prefix queries should be analyzed (default: false)</summary>
		public SearchExistsDescriptor<T> AnalyzeWildcard(bool analyze_wildcard = true) => AssignParam(p=>p.AnalyzeWildcard(analyze_wildcard));

		///<summary>The default operator for query string query (AND or OR)</summary>
		public SearchExistsDescriptor<T> DefaultOperator(DefaultOperator default_operator) => AssignParam(p=>p.DefaultOperator(default_operator));

		///<summary>The field to use as default where no field prefix is given in the query string</summary>
		public SearchExistsDescriptor<T> Df(string df) => AssignParam(p=>p.Df(df));

		///<summary>Specify whether format-based query failures (such as providing text to a numeric field) should be ignored</summary>
		public SearchExistsDescriptor<T> Lenient(bool lenient = true) => AssignParam(p=>p.Lenient(lenient));

		///<summary>Specify whether query terms should be lowercased</summary>
		public SearchExistsDescriptor<T> LowercaseExpandedTerms(bool lowercase_expanded_terms = true) => AssignParam(p=>p.LowercaseExpandedTerms(lowercase_expanded_terms));

		///<summary>The URL-encoded request definition</summary>
		public SearchExistsDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SearchExistsDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SearchShards <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html</pre></summary>
	public partial class SearchShardsDescriptor<T>  : RequestDescriptorBase<SearchShardsDescriptor<T>,SearchShardsRequestParameters, ISearchShardsRequest>, ISearchShardsRequest
	{ 
		Indices ISearchShardsRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchShardsRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/{index}/{type}/_search_shards</summary>
		public SearchShardsDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		

			///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchShardsDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchShardsDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchShardsDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchShardsDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchShardsDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchShardsDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchShardsDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specific routing value</summary>
		public SearchShardsDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public SearchShardsDescriptor<T> Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchShardsDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchShardsDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchShardsDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>The URL-encoded request definition</summary>
		public SearchShardsDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SearchShardsDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SearchTemplate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</pre></summary>
	public partial class SearchTemplateDescriptor<T>  : RequestDescriptorBase<SearchTemplateDescriptor<T>,SearchTemplateRequestParameters, ISearchTemplateRequest>, ISearchTemplateRequest
	{ 
		Indices ISearchTemplateRequest.Index => Self.RouteValues.Get<Indices>("index");
		Types ISearchTemplateRequest.Type => Self.RouteValues.Get<Types>("type");
			/// <summary>/_search/template</summary>
		public SearchTemplateDescriptor() : base(r=> r.Required("index", (Indices)typeof(T)).Required("type", (Types)typeof(T))){}
		

			///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchTemplateDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchTemplateDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices</summary>
		public SearchTemplateDescriptor<T> AllIndices() => this.Index(Indices.All);

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchTemplateDescriptor<T> Type(Types type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchTemplateDescriptor<T> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (Types)typeof(TOther)));

		///<summary>A comma-separated list of document types to search; leave empty to perform the operation on all types</summary>
		public SearchTemplateDescriptor<T> AllTypes() => this.Type(Types.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SearchTemplateDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SearchTemplateDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SearchTemplateDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SearchTemplateDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>A comma-separated list of specific routing values</summary>
		public SearchTemplateDescriptor<T> Routing(params string[] routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Specify how long a consistent view of the index should be maintained for scrolled search</summary>
		public SearchTemplateDescriptor<T> Scroll(string scroll) => AssignParam(p=>p.Scroll(scroll));

		///<summary>Search operation type</summary>
		public SearchTemplateDescriptor<T> SearchType(SearchType search_type) => AssignParam(p=>p.SearchType(search_type));

		///<summary>The URL-encoded request definition</summary>
		public SearchTemplateDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SearchTemplateDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotCreate <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotDescriptor  : RequestDescriptorBase<SnapshotDescriptor,SnapshotRequestParameters, ISnapshotRequest>, ISnapshotRequest
	{ 
		Name ISnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name ISnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}</summary>
///<param name="repository"> this parameter is required</param>		
///<param name="snapshot"> this parameter is required</param>
		public SnapshotDescriptor(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public SnapshotDescriptor WaitForCompletion(bool wait_for_completion = true) => AssignParam(p=>p.WaitForCompletion(wait_for_completion));

		///<summary>The URL-encoded request definition</summary>
		public SnapshotDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SnapshotDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotCreateRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class CreateRepositoryDescriptor  : RequestDescriptorBase<CreateRepositoryDescriptor,CreateRepositoryRequestParameters, ICreateRepositoryRequest>, ICreateRepositoryRequest
	{ 
		Name ICreateRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
			/// <summary>/_snapshot/{repository}</summary>
///<param name="repository"> this parameter is required</param>
		public CreateRepositoryDescriptor(Name repository) : base(r=>r.Required("repository", repository)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public CreateRepositoryDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Explicit operation timeout</summary>
		public CreateRepositoryDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Whether to verify the repository after creation</summary>
		public CreateRepositoryDescriptor Verify(bool verify = true) => AssignParam(p=>p.Verify(verify));

		///<summary>The URL-encoded request definition</summary>
		public CreateRepositoryDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public CreateRepositoryDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotDelete <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteSnapshotDescriptor  : RequestDescriptorBase<DeleteSnapshotDescriptor,DeleteSnapshotRequestParameters, IDeleteSnapshotRequest>, IDeleteSnapshotRequest
	{ 
		Name IDeleteSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IDeleteSnapshotRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}</summary>
///<param name="repository"> this parameter is required</param>		
///<param name="snapshot"> this parameter is required</param>
		public DeleteSnapshotDescriptor(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteSnapshotDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public DeleteSnapshotDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteSnapshotDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotDeleteRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class DeleteRepositoryDescriptor  : RequestDescriptorBase<DeleteRepositoryDescriptor,DeleteRepositoryRequestParameters, IDeleteRepositoryRequest>, IDeleteRepositoryRequest
	{ 
		Names IDeleteRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
			/// <summary>/_snapshot/{repository}</summary>
///<param name="repository"> this parameter is required</param>
		public DeleteRepositoryDescriptor(Names repository) : base(r=>r.Required("repository", repository)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public DeleteRepositoryDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Explicit operation timeout</summary>
		public DeleteRepositoryDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public DeleteRepositoryDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public DeleteRepositoryDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotGet <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetSnapshotDescriptor  : RequestDescriptorBase<GetSnapshotDescriptor,GetSnapshotRequestParameters, IGetSnapshotRequest>, IGetSnapshotRequest
	{ 
		Name IGetSnapshotRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names IGetSnapshotRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}</summary>
///<param name="repository"> this parameter is required</param>		
///<param name="snapshot"> this parameter is required</param>
		public GetSnapshotDescriptor(Name repository, Names snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetSnapshotDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public GetSnapshotDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetSnapshotDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotGetRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class GetRepositoryDescriptor  : RequestDescriptorBase<GetRepositoryDescriptor,GetRepositoryRequestParameters, IGetRepositoryRequest>, IGetRepositoryRequest
	{ 
		Names IGetRepositoryRequest.RepositoryName => Self.RouteValues.Get<Names>("repository");
			/// <summary>/_snapshot</summary>
		public GetRepositoryDescriptor() : base(){}
		

			///<summary>A comma-separated list of repository names</summary>
		public GetRepositoryDescriptor RepositoryName(Names repository) => Assign(a=>a.RouteValues.Optional("repository", repository));

	
		///<summary>Explicit operation timeout for connection to master node</summary>
		public GetRepositoryDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Return local information, do not retrieve the state from master node (default: false)</summary>
		public GetRepositoryDescriptor Local(bool local = true) => AssignParam(p=>p.Local(local));

		///<summary>The URL-encoded request definition</summary>
		public GetRepositoryDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public GetRepositoryDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotRestore <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class RestoreDescriptor  : RequestDescriptorBase<RestoreDescriptor,RestoreRequestParameters, IRestoreRequest>, IRestoreRequest
	{ 
		Name IRestoreRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Name IRestoreRequest.Snapshot => Self.RouteValues.Get<Name>("snapshot");
			/// <summary>/_snapshot/{repository}/{snapshot}/_restore</summary>
///<param name="repository"> this parameter is required</param>		
///<param name="snapshot"> this parameter is required</param>
		public RestoreDescriptor(Name repository, Name snapshot) : base(r=>r.Required("repository", repository).Required("snapshot", snapshot)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public RestoreDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Should this request wait until the operation has completed before returning</summary>
		public RestoreDescriptor WaitForCompletion(bool wait_for_completion = true) => AssignParam(p=>p.WaitForCompletion(wait_for_completion));

		///<summary>The URL-encoded request definition</summary>
		public RestoreDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public RestoreDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotStatus <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class SnapshotStatusDescriptor  : RequestDescriptorBase<SnapshotStatusDescriptor,SnapshotStatusRequestParameters, ISnapshotStatusRequest>, ISnapshotStatusRequest
	{ 
		Name ISnapshotStatusRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
		Names ISnapshotStatusRequest.Snapshot => Self.RouteValues.Get<Names>("snapshot");
			/// <summary>/_snapshot/_status</summary>
		public SnapshotStatusDescriptor() : base(){}
		

			///<summary>A repository name</summary>
		public SnapshotStatusDescriptor RepositoryName(Name repository) => Assign(a=>a.RouteValues.Optional("repository", repository));

		///<summary>A comma-separated list of snapshot names</summary>
		public SnapshotStatusDescriptor Snapshot(Names snapshot) => Assign(a=>a.RouteValues.Optional("snapshot", snapshot));

	
		///<summary>Explicit operation timeout for connection to master node</summary>
		public SnapshotStatusDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>The URL-encoded request definition</summary>
		public SnapshotStatusDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SnapshotStatusDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for SnapshotVerifyRepository <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html</pre></summary>
	public partial class VerifyRepositoryDescriptor  : RequestDescriptorBase<VerifyRepositoryDescriptor,VerifyRepositoryRequestParameters, IVerifyRepositoryRequest>, IVerifyRepositoryRequest
	{ 
		Name IVerifyRepositoryRequest.RepositoryName => Self.RouteValues.Get<Name>("repository");
			/// <summary>/_snapshot/{repository}/_verify</summary>
///<param name="repository"> this parameter is required</param>
		public VerifyRepositoryDescriptor(Name repository) : base(r=>r.Required("repository", repository)){}
		

		
		///<summary>Explicit operation timeout for connection to master node</summary>
		public VerifyRepositoryDescriptor MasterTimeout(string master_timeout) => AssignParam(p=>p.MasterTimeout(master_timeout));

		///<summary>Explicit operation timeout</summary>
		public VerifyRepositoryDescriptor Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>The URL-encoded request definition</summary>
		public VerifyRepositoryDescriptor Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public VerifyRepositoryDescriptor FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Suggest <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/search-suggesters.html</pre></summary>
	public partial class SuggestDescriptor<T>  : RequestDescriptorBase<SuggestDescriptor<T>,SuggestRequestParameters, ISuggestRequest>, ISuggestRequest
	{ 
		Indices ISuggestRequest.Index => Self.RouteValues.Get<Indices>("index");
			/// <summary>/_suggest</summary>
		public SuggestDescriptor() : base(){}
		

			///<summary>A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</summary>
		public SuggestDescriptor<T> Index(Indices index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</summary>
		public SuggestDescriptor<T> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (Indices)typeof(TOther)));

		///<summary>A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices</summary>
		public SuggestDescriptor<T> AllIndices() => this.Index(Indices.All);

	
		///<summary>Whether specified concrete indices should be ignored when unavailable (missing or closed)</summary>
		public SuggestDescriptor<T> IgnoreUnavailable(bool ignore_unavailable = true) => AssignParam(p=>p.IgnoreUnavailable(ignore_unavailable));

		///<summary>Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)</summary>
		public SuggestDescriptor<T> AllowNoIndices(bool allow_no_indices = true) => AssignParam(p=>p.AllowNoIndices(allow_no_indices));

		///<summary>Whether to expand wildcard expression to concrete indices that are open, closed or both.</summary>
		public SuggestDescriptor<T> ExpandWildcards(ExpandWildcards expand_wildcards) => AssignParam(p=>p.ExpandWildcards(expand_wildcards));

		///<summary>Specify the node or shard the operation should be performed on (default: random)</summary>
		public SuggestDescriptor<T> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specific routing value</summary>
		public SuggestDescriptor<T> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>The URL-encoded request definition</summary>
		public SuggestDescriptor<T> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public SuggestDescriptor<T> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Termvectors <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html</pre></summary>
	public partial class TermVectorsDescriptor<TDocument>  : RequestDescriptorBase<TermVectorsDescriptor<TDocument>,TermVectorsRequestParameters, ITermVectorsRequest<TDocument>>, ITermVectorsRequest<TDocument>
	{ 
		IndexName ITermVectorsRequest<TDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName ITermVectorsRequest<TDocument>.Type => Self.RouteValues.Get<TypeName>("type");
		Id ITermVectorsRequest<TDocument>.Id => Self.RouteValues.Get<Id>("id");
			/// <summary>/{index}/{type}/_termvectors</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>
		public TermVectorsDescriptor(IndexName index, TypeName type) : base(r=>r.Required("index", index).Required("type", type)){}
		

		/// <summary>/{index}/{type}/_termvectors</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public TermVectorsDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>The index in which the document resides.</summary>
		public TermVectorsDescriptor<TDocument> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The index in which the document resides.</summary>
		public TermVectorsDescriptor<TDocument> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document.</summary>
		public TermVectorsDescriptor<TDocument> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document.</summary>
		public TermVectorsDescriptor<TDocument> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

		///<summary>The id of the document, when not specified a doc param should be supplied.</summary>
		public TermVectorsDescriptor<TDocument> Id(Id id) => Assign(a=>a.RouteValues.Optional("id", id));

	
		///<summary>Specifies if total term frequency and document frequency should be returned.</summary>
		public TermVectorsDescriptor<TDocument> TermStatistics(bool term_statistics = true) => AssignParam(p=>p.TermStatistics(term_statistics));

		///<summary>Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.</summary>
		public TermVectorsDescriptor<TDocument> FieldStatistics(bool field_statistics = true) => AssignParam(p=>p.FieldStatistics(field_statistics));

		///<summary>Specifies if distributed frequencies should be returned instead shard frequencies.</summary>
		public TermVectorsDescriptor<TDocument> Dfs(bool dfs = true) => AssignParam(p=>p.Dfs(dfs));

		///<summary>A comma-separated list of fields to return.</summary>
		public TermVectorsDescriptor<TDocument> Fields(params string[] fields) => AssignParam(p=>p.Fields(fields));
			
		///<summary>A comma-separated list of fields to return.</summary>
		public TermVectorsDescriptor<TDocument> Fields(params Expression<Func<TDocument, object>>[] fields)  =>
			AssignParam(p=>p._Fields(fields));

		///<summary>Specifies if term offsets should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Offsets(bool offsets = true) => AssignParam(p=>p.Offsets(offsets));

		///<summary>Specifies if term positions should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Positions(bool positions = true) => AssignParam(p=>p.Positions(positions));

		///<summary>Specifies if term payloads should be returned.</summary>
		public TermVectorsDescriptor<TDocument> Payloads(bool payloads = true) => AssignParam(p=>p.Payloads(payloads));

		///<summary>Specify the node or shard the operation should be performed on (default: random).</summary>
		public TermVectorsDescriptor<TDocument> Preference(string preference) => AssignParam(p=>p.Preference(preference));

		///<summary>Specific routing value.</summary>
		public TermVectorsDescriptor<TDocument> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>Parent id of documents.</summary>
		public TermVectorsDescriptor<TDocument> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Specifies if request is real-time as opposed to near-real-time (default: true).</summary>
		public TermVectorsDescriptor<TDocument> Realtime(bool realtime = true) => AssignParam(p=>p.Realtime(realtime));

		///<summary>Explicit version number for concurrency control</summary>
		public TermVectorsDescriptor<TDocument> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public TermVectorsDescriptor<TDocument> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>The URL-encoded request definition</summary>
		public TermVectorsDescriptor<TDocument> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public TermVectorsDescriptor<TDocument> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
	
	///<summary>descriptor for Update <pre>http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html</pre></summary>
	public partial class UpdateDescriptor<TDocument, TPartialDocument>  : RequestDescriptorBase<UpdateDescriptor<TDocument, TPartialDocument>,UpdateRequestParameters, IUpdateRequest<TDocument, TPartialDocument>>, IUpdateRequest<TDocument, TPartialDocument>
	{ 
		Id IUpdateRequest<TDocument, TPartialDocument>.Id => Self.RouteValues.Get<Id>("id");
		IndexName IUpdateRequest<TDocument, TPartialDocument>.Index => Self.RouteValues.Get<IndexName>("index");
		TypeName IUpdateRequest<TDocument, TPartialDocument>.Type => Self.RouteValues.Get<TypeName>("type");
			/// <summary>/{index}/{type}/{id}/_update</summary>
///<param name="index"> this parameter is required</param>		
///<param name="type"> this parameter is required</param>		
///<param name="id"> this parameter is required</param>
		public UpdateDescriptor(IndexName index, TypeName type, Id id) : base(r=>r.Required("index", index).Required("type", type).Required("id", id)){}
		

		/// <summary>/{index}/{type}/{id}/_update</summary>
		
///<param name="document"> describes an elasticsearch document of type T, allows implicit conversion from numeric and string ids </param>
		public UpdateDescriptor(DocumentPath<TDocument> document) : base(r=>r.Required("index", document.Self.Index).Required("type", document.Self.Type).Required("id", document.Self.Id)){ this.DocumentFromPath(document.Document); }
		partial void DocumentFromPath(TDocument document);

			///<summary>The name of the index</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Index(IndexName index) => Assign(a=>a.RouteValues.Optional("index", index));

		///<summary>The name of the index</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Index<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("index", (IndexName)typeof(TOther)));

		///<summary>The type of the document</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Type(TypeName type) => Assign(a=>a.RouteValues.Optional("type", type));

		///<summary>The type of the document</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Type<TOther>() where TOther : class => Assign(a=>a.RouteValues.Optional("type", (TypeName)typeof(TOther)));

	
		///<summary>Explicit write consistency setting for the operation</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Consistency(Consistency consistency) => AssignParam(p=>p.Consistency(consistency));

		///<summary>The script language (default: groovy)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Lang(string lang) => AssignParam(p=>p.Lang(lang));

		///<summary>ID of the parent document. Is is only used for routing and when for the upsert request</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Parent(string parent) => AssignParam(p=>p.Parent(parent));

		///<summary>Refresh the index after performing the operation</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Refresh(bool refresh = true) => AssignParam(p=>p.Refresh(refresh));

		///<summary>Specify how many times should the operation be retried when a conflict occurs (default: 0)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> RetryOnConflict(long retry_on_conflict) => AssignParam(p=>p.RetryOnConflict(retry_on_conflict));

		///<summary>Specific routing value</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Routing(string routing) => AssignParam(p=>p.Routing(routing));

		///<summary>The URL-encoded script definition (instead of using request body)</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> ScriptQueryString(string script) => AssignParam(p=>p.Script(script));

		///<summary>The id of a stored script</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> ScriptId(string script_id) => AssignParam(p=>p.ScriptId(script_id));

		///<summary>True if the script referenced in script or script_id should be called to perform inserts - defaults to false</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> ScriptedUpsert(bool scripted_upsert = true) => AssignParam(p=>p.ScriptedUpsert(scripted_upsert));

		///<summary>Explicit operation timeout</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Timeout(string timeout) => AssignParam(p=>p.Timeout(timeout));

		///<summary>Explicit timestamp for the document</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Timestamp(string timestamp) => AssignParam(p=>p.Timestamp(timestamp));

		///<summary>Expiration time for the document</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Ttl(string ttl) => AssignParam(p=>p.Ttl(ttl));

		///<summary>Explicit version number for concurrency control</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Version(long version) => AssignParam(p=>p.Version(version));

		///<summary>Specific version type</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> VersionType(VersionType version_type) => AssignParam(p=>p.VersionType(version_type));

		///<summary>Specifying as true will cause Elasticsearch to check if there are changes and, if there aren&#226;€™t, turn the update request into a noop.</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> DetectNoop(bool detect_noop = true) => AssignParam(p=>p.DetectNoop(detect_noop));

		///<summary>The URL-encoded request definition</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> Source(string source) => AssignParam(p=>p.Source(source));

		///<summary>Comma separated list of filters used to reduce the response returned by Elasticsearch</summary>
		public UpdateDescriptor<TDocument, TPartialDocument> FilterPath(string filter_path) => AssignParam(p=>p.FilterPath(filter_path));
	
	}
}